<html lang="de">
  <!doctype html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>GraphQL Workshop</title>

    <link rel="stylesheet" href="revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="revealjs/styles.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-state="title">
          <h4 style="margin-bottom: 3rem; font-size: 3rem">
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>
          <h2 class="title" style="font-size: 7rem">
            <b>GraphQL</b>
          </h2>
          <h3 class="title" style="font-size: 5rem; margin-bottom: 3rem">
            <b>Dein Praxis-Einstieg</b>
          </h3>
          <h3 class="title" style="font-size: 3rem; margin-bottom: 3rem">
            <b>BaselOne, 18. Oktober 2023</b>
          </h3>

          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Slides (online)</span></h3>
            <p>
              <a class="Link" href="https://graphql.schule/baselone23"
                >https://graphql.schule/baselone23</a
              >
            </p>
          </div>
          <div style="margin-top: 6rem">
            <h3><span class="transparent-bg">Workspace Installation</span></h3>
            <p>
              <a
                class="Link"
                href="https://github.com/nilshartmann/spring-graphql-training/blob/main/INSTALL.md"
                >https://graphql.schule/install</a
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p style="margin-top: 2rem">
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p style="margin-top: 2rem">
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>
          <p></p>
          <p style="margin-top: 5rem">
            Java | JavaScript, TypeScript | React | GraphQL
          </p>
          <div style="display: flex; justify-content: center; margin-top: 2rem">
            <div style="margin-left: 15px">
              <a href="https://graphql.schule/video-kurs"
                ><img
                  style="max-height: 450px"
                  src="images/screenshot-graphql-kurs.png"
                /><br />https://graphql.schule/video-kurs</a
              >
              <br />
            </div>
            <!--  -->
            <div style="margin-left: 100px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!--        <section>-->
        <!--          <h2>Und ihr?</h2>-->
        <!--          <ul>-->
        <!--            <li>Stellt euch doch bitte kurz vor...</li>-->
        <!--            <li>-->
        <!--              Eure Vorkenntnisse in <b>GraphQL</b>, <b>Java</b>, <b>Spring?</b>,-->
        <!--              <b>React/TypeScript</b>-->
        <!--            </li>-->
        <!--            <li>-->
        <!--              W√ºnsche f√ºr diese Schulung? Besondere Themen oder Interessen?-->
        <!--            </li>-->
        <!--          </ul>-->
        <!--        </section>-->

        <section data-markdown>
          <textarea data-template>
## Agenda

* Teil 1: GraphQL
  * Was ist GraphQL?
  * [Die Abfragesprache](#/graphql-sprache)

* Teil 2: [GraphQL Anwendungen bauen](#/graphql-apis-bereitstellen)
    * [Das Schema definieren](#/schema)
    * [GraphQL APIs mit Spring for GraphQL](#/spring-for-graphql)
    * Optimierungen: [DataLoader](#/dataloader)
* Jeder Zeit: Eure Fragen!

---

## Zeitplan

* 13:30-17:00

* Zwischendurch Pausen (?)

---

# GraphQL


_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---

# GraphQL


_"GraphQL is a **query language for APIs** and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a **runtime for fulfilling** those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with **your existing data**"_ ([https://graphql.org](https://graphql.org))

---
## Die Beispiel-Anwendung "Publy"

<img style="border: 1px solid grey" src="images/publy-screenshot.png" />

[http://localhost:3000](http://localhost:3000)

---
### Eine API f√ºr Publy

* Ansatz 1: Backend bestimmt Aussehen der Endpunkte / Daten
  * REST
* <img src="images/arten-von-apis_rest.png" width="2400px" style="margin-top:120px"/>
---
### Eine API f√ºr Publy

* Ansatz 2: Client diktiert die API nach seinen Anforderungen
  * "Backend for Frontend"          
* <img src="images/arten-von-apis_02_bff.png" width="2400px" style="margin-top:120px"/>

---
### Eine API f√ºr Publy

* Ansatz 3: GraphQL
  * Aus Ansatz 1: Server bestimmt, wie Datenmodell aussieht
* <img src="images/arten-von-apis_03_graphql_01.png" width="2400px" style="margin-top:120px"/>  
  
---
### Eine API f√ºr Publy
<!-- .slide: class="no-fragment" -->

* Ansatz 3: GraphQL
  * Aus Ansatz 1: Server bestimmt, wie Datenmodell aussieht
  * ...aber Client kann pro Ansicht w√§hlen, welche Daten er daraus ben√∂tigt
* <img src="images/arten-von-apis_03_graphql_02.png" width="2400px" style="margin-top:120px"/>  

  
---
## Beispiel: GraphiQL

<img style="border: 1px solid grey" src="images/screenshot-graphiql.png" />

[http://localhost:8080](http://localhost:8080)


---
## Beispiel: GraphQL Tooling

* <!-- .element: class="demo" --> IntelliJ IDEA
  * <!-- .element: class="demo" --> graphql-Extension (hello.graphql)
  * <!-- .element: class="demo" --> GraphQL.md im publy-Verzeichnis
  * <!-- .element: class="demo" --> language=GraphQL in einer leeren Java-Datei

---
## Spezifikation

* https://spec.graphql.org/
* Umfasst:
  * Query Sprache und -Ausf√ºhrung
  * Schema Definition Language
* Kein fertiges Produkt, keine fertige Bibliothek
    * Es gibt Bibliotheken, die dir helfen, GraphQL APIs zu implementieren und bereitzustellen
    * Die abgefragten Daten m√ºssen wir selbst ermitteln
    * GraphQL macht keine Aussage dar√ºber, wo diese Daten herkommen (Datenbank, Micro-Service, Berechnung ...)


---
<!-- .slide: id="graphql-sprache" -->
# Die GraphQL Abfrage-Sprache
---

### Sprache, um **Felder** aus einem **Objekt-Graphen** abzufragen

```graphql
  query {
    story {
      id title writtenBy {
        id user { name }
      }
    }
  }

---

### Felder k√∂nnen **Argumente** haben

<pre><code class="graphql">
  query {
    story(storyId: 5) {
      id title writtenBy {
        id user { name }
      }
    }
  }
</code></pre>

---

### Die **Antwort** sieht immer so aus, wie die Abfrage

<img src="images/query-antwort.png" />

---

### Operation-Type

Ausgef√ºhrt werden **Operationen**.
Der **Operation-Type** beschreibt, was in der Anfrage getan werden soll

* **query**: Daten lesen (Default-Operation, Schl√ºsselwort "query" kann weggelassen werden)
* **mutation**: Daten ver√§ndern
* **subscription**: Daten vom Server bekommen, sobald sie erzeugt wurden (√§hnlich wie Events)

---


### Operation-Type

Der Operation-Type bestimmt auch den Einstiegspunkt in den Objekt-Graphen

<img src="images/einstiegspunkte.png" />

---

### Namen von Operationen

* Operationen k√∂nnen **Namen** haben.
* Das ist vor allem f√ºr Debugging und Code-Generatoren relevant

* <pre class="fragment"><code class="graphql">
query NewestStory {
    story {
      id
      title
    }
}
</code></pre>

---

### Fragmente

* Mit einem **Fragment** beschreibst Du eine wiederverwendbare Menge von Feldern
* ```graphql
  fragment BaseMember on Member {
      id joined
      user { is username }
  }

  query {
      story {
        writtenBy { ...BaseMember }

        reactions {
          givenBy { ...BaseMember }
        }
      }
  }
  ```

---

### Union-Typen

Ein **Union-Type** kann mehr als einen Typ zur√ºckliefern:

```graphql
  mutation  addComment
      (input: { storyId: "1", content: "..." }) {

      ...on AddCommentSuccessPayload {
        newComment { id }
      }

      ...on AddCommentFailurePayload {
        errorMessage
      }
  }
```

---
### Interfaces

* Ein Interface erzwingt gemeinsame Felder an den Objekten, die das Interface implementieren (√§hnlich
    wie in Java mit Methoden)

* Beispiel: `id` und `createdAt` sind am `Node`-Interface definiert

* ```graphql
  query {
      node(id: "...") {

        id
        createdAt

        ...on Story { title body }
        ...on Comment { content }
      }
  }
  ```


---

### Variablen

* Queries k√∂nnen **Variablen** haben.
* Variablen m√ºssen im Query deklariert werden
* Werte f√ºr Variablen werden in einem eigenen JSON-Objekt an den Server geschickt

* ```graphql
  query ($storyId: ID!) {
    story(id: $storyId) {
      id
      title body
    }
  }
  ```
  
---

## √úbung: Einen Query ausf√ºhren

_Mach' dich mit der GraphQL-Abfragesprache vertraut_

* √ñffne GraphiQL auf diesem Demo-Server: https://graphql.schule/publy
* Versuche einen Query auszuf√ºhren, der die ersten zehn Stories zur√ºckliefert und folgende Felder abfragt:
  * Id, Titel, Excerpt, Ver√∂ffentlichungsdatum, Wer hat die Story geschrieben und die jeweils ersten zehn Kommentare
  * Kannst Du den Query so erweitern, dass er die ersten zehn _neusten_ Stories zur√ºckliefert?
* Bau eine Fragment (`Author`), das aus dem `Member` dessen Id, sowie `name` und `id` des Users enth√§lt
  * Verwende das Fragment, um in den Stories und den Kommentaren jeweils die Member-Informationen abzufragen
  * In den Stories zus√§tzlich noch `skills` des Members abfragen
* Du kannst Code-Completion und den `Docs`-Explorer (Buch-Symbol links oben) verwenden, um die API zu untersuchen
* M√∂gliche L√∂sung: [https://graphql.schule/queries](https://graphql.schule/queries)

---

### GraphQL Requests

* <!-- .element: class="demo" --> HTTP Request an die GraphQL API
  * <!-- .element: class="demo" --> `app/demo/request.http` im publy-Ordner
  * <!-- .element: class="demo" --> Fehler (falsches Feld) zeigen
---

## GraphQL Requests

* √úblicherweise nur HTTP POST-Request
  * andere HTTP Verben spielen keine Rolle
  * HTTP Status-Code meist 200 OK, auch im Fehlerfall!
  * Gro√üer Unterscheid zu REST APIs
* Antwort-JSON-Objekt besteht aus maximal drei Feldern:
  * `data`: Die gelesenen Daten (Struktur darunter entspricht der Abfrage)
  * `errors`: Liste mit (technischen) Fehlern, u.a. Fehlermeldung
  * `extensions`: Freibelegbares Objekt f√ºr propriet√§re Erweiterungen (z.B. Debug-Informationen)
* Eine Spezifikation daf√ºr ist [in Arbeit](https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md)


---

### Teil II
<!-- .slide: id="graphql-apis-bereitstellen" -->
# GraphQL APIs bereitstellen

---
### Wir ver√∂ffentlichen mit GraphQL eine fachliche API
* Welche Daten wir zur Verf√ºgung stellen ist unsere Aufgabe
* Wir legen fest, in welcher Form die Daten zur Verf√ºgung gestellt werden
  * üëâ Wir legen damit explizit selbst fest, wie unsere API aussehen soll 
  * üëâ GraphQL erzeugt die API nicht auf "magische" Weise selbst 
  * üõ†Ô∏è Es gibt allerdings Tools, die z.B. f√ºr eine Datenbank eine API erzeugen k√∂nnen 

---
<!-- .slide: id="schema" -->
### Das GraphQL Schema

* GraphQL APIs m√ºssen in einem Schema beschrieben werden.
* In dem Schema werden Objekte (Typen) mit Feldern beschrieben.
* Das Schema selbst ist zur Laufzeit mit einem _Introspection Query_ abfragbar
  * üßë‚Äçüíª Beispiel in GraphiQL
* Je nach Framework gibt's unterschiedliche M√∂glichkeiten, das Schema zu definieren
  * **Schema-first**: erst Schema beschreiben, dann implementieren
  * **Code-first**: Schema wird aus (Java-)Code generiert, z.B. mit Annotations
  * **Spring for GraphQL** verwendet Schema-first
  * **MicroProfile GraphQL** (z.B. Quarkus) verwendet Code-first

---

### Beschreibung des Schemas

* Mit der [Schema Definition Language](https://graphql.org/learn/schema/) 
* Per [Java API](https://www.graphql-java.com/documentation/schema) 
* In der Regel wird die **SDL** verwendet 

---

### Die SDL

* <!-- .element: class="demo" --> Demo: Schema-Definition 
  * <!-- .element: class="demo" --> Im workspace-Ordner
  * <!-- .element: class="demo" --> Story und Member
  * <!-- .element: class="demo" --> Argument!
  * <!-- .element: class="demo" --> R√ºckgabewert-String
  * <!-- .element: class="demo" --> Doku

---

### Die SDL

Beschreibung eines *Objekt Types*

<pre><code class="graphql">
  type Story {
    id: ID!

    title: String!
    body: String!
  }
</code></pre>

* Beschrieben werden **Felder** mit **Return Types**
* Ein Ausrufezeichen zeigt an, dass das Feld nicht _nullable_ ist

---

### Dokumentation und Kommentare

* Dokumentation mit drei doppelten Anf√ºhrungszeichen
  * Markdown zur Formatierung erlaubt
* Kommentare mit Hash-Zeichen
  * Dokumentation ist Bestandteil der API, Kommentare nicht

* ```graphql
  """
  A `Story` is the main object in our service.
  """
  type Story {
    """Identifies this object"""
    id: ID!

    # todo: implement new tags-field (PROJ-666)
  }
  ```

---

## Skalare Typen

* Skalare Typen entsprechen primitiven Typen in Java
  * Sind die Enden im Objekt-Graphen
* Standard-Typen: ID, String, Boolean, Int, Float
  * ID wird als String gelesen und geschrieben, soll aber nicht interpretiert werden


* ```graphql
  type Member {
    id: ID!

    username: String!

    # no exclamation mark: can be null
    likes: Int

    amount: Float!

    activeMember: Boolean
  }
  ```
  

* Man kann eigene skalare Typen bauen
---

### Aufz√§hlungstypen (enum)

* Wie in Java

* <!-- .element: style="min-width: 500px" -->
  ```graphql
  enum ReactionType {
    like,
    laugh,
    thumbUp
  }
  ```

---

### Referenzen

* Referenzen auf andere Objekt-Typen

* <!-- .element: style="min-width: 900px" -->
  ```graphql
  type Member {
    # ...
  }

  type Comment {
    # ...
  }

  type Story {
    """Reference to the Member that has written this Story"""
    writtenBy: Member!

    comments: [Comment!]!

  }
  ```

---

### Argumente

* Felder k√∂nnen Argumente haben
  * Solche Felder werden auch _Methoden_ genannt
* Die Felder mit ihren Namen und Typen m√ºssen in der API definiert werden
  * Namen sind entscheidend (wie "named arguments" in Kotlin), nicht Reihenfolge (wie in Java)
* Argumente k√∂nnen Default-Werte haben
* Achtung! Argumente d√ºrfen keine Objekt-Typen sein!  


* ```graphql
  type Story {

    # Mandatory argument maxLength, defaults to 20
    #  if not specified by the client
    excerpt(maxLength: Int! = 20): String!

  }
  ```

---

### Root-Typen

* Root-Typen bilden den Einstiegspunkt f√ºr Queries in den Objekt-Graphen
* Root-Typen sind **Query**, **Mutation** und **Subscription**
  * **Query** ist Pflicht, die beiden anderen Typen optional
* Syntax und Verhalten genauso wie bei Objekt-Typen
* Felder an den Root-Typen werden auch **Root-Felder** genannt


* ```graphql
  type Query {
    """Returns a List of all stories"""
    stories: [Story!]!

    """Returns a story by its ID or null"""
    story(id: ID!): Story
  }

  type Mutation {
    addComment(storyId: ID!, memberId: ID!, content: String!): Comment!
  }
  ```
---

### Input-Typen

* Objekt-Typen k√∂nnen nicht als Argument an ein Feld √ºbergeben
* Als Argumente an Feldern k√∂nnen nur skalare Typen, Enums und Input-Typen √ºbergeben werden.
* Ein Input-Type wird mit `input` definiert, sieht ansonsten aus wie ein Objekt-Type
  * Ein Input-Type darf keine Objekt-Typen referenzieren

* ```graphql
  input AddCommentInput {
    storyId: ID!
    memberId: ID!
    content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
  ```

---

### Union Types

* Union Types bilden eine Menge von anderen Typen
* Ein Feld kann ein Typen aus dieser Menge zur√ºckliefern ("A _oder_ B")


* ```graphql
  type AddCommentSuccess { newComment: Comment! }
  type AddCommentFailed { errorMessage: String! }

  union AddCommentResult = AddCommentSuccess | AddCommentFailed

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentResult!
  }
  ```


---

### Interfaces

* Mit einem Interface wird erzwungen, dass Objekte √ºber gleiche Felder verf√ºgen
  * Vergleichbar mit Interfaces in Java


* ```graphql
  interface Node {
    id: ID!
  }

  type Story implements Node {
    id: ID!  # Field defined in Node-Interface

    title: String! # additional Story fields
  }

  type Comment implements Node {
    id: ID! 

    content: String!
  }

  type User {
    id: ID!
    email: String
  }

  type Query {
    # Returns either Story or Comment, but not User

    node(id: ID!): Node 
  }
  ```

---

### Schema-Evolution

* In GraphQL gibt es nur _eine Version_ der API (kein `/api/v1`, `/api/v2`)
* Das Schema kann jederzeit erweitert werden
  * Clients fragen explizit Felder ab, d.h. durch neue Felder werden sie nicht beeintr√§chtigt
* Man kann Felder mit `deprecated` markieren, um anzuzeigen, dass sie nicht genutzt werden sollen  

* ```graphql
  type Query {
    # Ausgangspunkt 
    getStoryById(id: ID!): Story
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story

    # Neues Feld, beeintr√§chtigt bestehenden Client nicht
    stories: [Story!]!
  }
  ```

* ```graphql
  type Query {
    getStoryById(id: ID!): Story @deprecated("Use story instead")
    story(id: ID!): Story

    stories: [Story!]!
  }
  ```
---

### √úbung: Schema beschreiben

---

### Vorbereitung: Das Repository

* `workspace`: Hier arbeiten wir, bitte in der IDE √∂ffnen
  * `workspace/publy-backend`: Spring Boot-Projekt, in dem wir die GraphQL API implementieren
  * `workspace/publy-userservice`: Spring Boot-Projekt mit dem UserService
  * `workspace/steps`: L√∂sungen f√ºr die einzelnen √úbungen
* Nach dem √ñffnen in der IDE sollte es keine Compilier-Fehler geben.
  * Bitte verwende mindestens *JDK 17*

* **Starten des Backends**  
  * Bitte f√ºhre in deiner IDE die Klasse `nh.publy.backend.PublyApplication` aus (darin enthalten ist eine `main`-Methode)
  * Wenn Du `http://localhost:8090` √∂ffnest, sollte GraphiQL ge√∂ffnet werden.
  * Wenn Du √Ñnderungen im Code machst und speicherst bzw. compilierst/baust, sollte sich das Backend automatisch neu starten.


---
### √úbung: Schema beschreiben
* Vervollst√§ndige die Datei `publy-backend/resources/graphql/publy.graphqls` und beschreibe darin eine API, die folgende Objekt-Typen enth√§lt:
  * **Member** mit `id` und `profileImage`
  * **Story** mit `id`, `title`, `body`, `excerpt` und einer Referenz (`writtenBy`) auf den Member
  * Alle Felder in den beiden Typen sind Pflicht (non-nullable), das `id`-Feld ist vom Typ `ID` alle anderen Strings
* Lege den Query-Typen mit folgenden Feldern an:
  * `stories`: Liefert eine Liste der `Story`-Objekte zur√ºck. Nicht nullable.
  * `story`: Liefert eine einzelne Story zur√ºck. Das Feld soll ein Argument haben: `storyId`. Das Feld kann `null` zur√ºckgeben
* Du kannst dir das Schema in GraphiQL anzeigen lassen (http://localhost:8090)
  * Zum Beispiel im "Documentation Explorer"  
  * Wenn Du in der IDE √Ñnderungen machst, musst Du die GraphiQL-Seite im Browser neu laden.
* Eine m√∂gliche L√∂sung findest Du in `steps/01-schema`

---


<!-- .slide: id="api-implementieren" -->
## Implementieren der GraphQL API

---

### Die Beispiel-Anwendung

<img src="images/publy-architektur.png" />

---

### Die Basis: graphql-java
<!-- .slide: id="graphql-java" -->

* <img style="height:350px" src="images/java-graphql-frameworks.png" />
* [graphql-java](https://www.graphql-java.com/) ist die Basis f√ºr alle (?) Java-basierten GraphQL-Frameworks
* Zust√§ndig f√ºr die eigentliche Ausf√ºhrung einer GraphQL Operation:
  * Schema-Definition mit der SDL (oder per Java API)
  * Parsen und validieren einer GraphQL Operation
* Andere GraphQL Frameworks abstrahieren davon und stellen weitere Features zur Verf√ºgung

---



### Verarbeitung eines GraphQL Queries (allgemein)


1. <!-- .element: class="xx-list" --> Query kommt an (HTTP Endpunkt)
2. Query wird geparst und validiert 
3. Ung√ºltige Queries werden abgewiesen (`errors`-Feld in der Antwort) 
4. F√ºr jedes Feld wird eine *Resolver-Funktion* (auch *DataFetcher* oder *Mapping-Funktion* genannt) aufgerufen, die verantwortlich daf√ºr ist, die Daten f√ºr das jeweilige Feld zu liefern
5. Die Ergebnisse der Resolver werden validiert (insb. hinsichtlich der Typen)
6. Das Ergebnis wird als `data`-Feld bereitsgestellt
7. Das Ergebnis wird an den Client zur√ºckgeschickt 

<!-- .slide: class="left" -->

<!-- end of the list -->

* <!-- .element: class="note" --> Unsere Aufgabe ist es, die Resolver zu implementieren

---

<!-- .slide: id="spring-for-graphql" -->
## Spring for GraphQL


* [Spring for GraphQL](https://spring.io/projects/spring-graphql) bietet eine Abstraktion von GraphQL-Java an
* Erstes Release von Spring for GraphQL enthalten in Spring Boot 2.7 (Mai 2022)

* Features:
  * HTTP-Endpunkt f√ºr Requests und Subscriptions automatisch
  * GraphiQL Integration per Property
  * Gewohntes Spring-Programmiermodell mit Annotationen etc.
  * [`spring-boot-starter-graphql`](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.graphql) f√ºr Spring Boot

---

### Das Schema in Spring for GraphQL

* Das Schema wird in Dateien mit der Endung `.graphqls` abgelegt
  * Verzeichnis: `src/main/resources/graphql`
* Spring Boot sammelt alle Schema-Dateien ein und erzeugt ein Schema daraus
* Typen k√∂nnen erweitert werden

* <pre class="fragment"><code class="graphql">
  # story.graphqls
  extend type Query {
    story(id: ID!): Story
  }

  # comment.graphqls
  extend type Query {
    comment(id: ID): Comment
  }
</code></pre>
---

## Spring for GraphQL

* <!-- .element: class="demo" --> Demo: Handler-Funktionen f√ºr Story 
* <!-- .element: class="demo" --> Query-Mapping!
* <!-- .element: class="demo" --> Argumente!

---

## Handler-Funktionen
<!-- .slide: id="handler-funktionen" -->


* *Handler-Funktionen* werden an `Controller`-Klassen implementiert

  * ```java
    @Controller
    public GraphQLController {

      @QueryMapping
      public String ping() { return "Pong!" }

    }
    ```
  
  * Handler-Funktionen f√ºr Felder am Query-Typen werden mit `@QueryMapping` annotiert
    * Mutations: `@MutationMapping`, Subscription: `@SubscriptionMapping`
  * Der Name der Methode entspricht dem Namen des Feldes des entsprechenden Root-Typen (oder explizit mit `value` setzen)

---

### Parameter von Handler-Funktionen

* `@Argument` um ein einzelnes Argument zu erhalten
* ```graphql
  type Query {
    ping(msg: String): String!
  }
  ```
* ```java
  @QueryMapping
  public String ping(@Argument String msg) { 
    return "Hello " + msg; 
  }
  ```  

---
### Parameter von Handler-Funktionen  
  
* F√ºr Input-Typen kann ein Pojo angegeben werden:
* ```graphql
  input GreetingInput { name: String, msg: String }

  type Query {
    greet(input: GreetingInput!): String!
  }
  ```
* ```java
  class GreetingInput { private String name; private String msg; /* getter+setter... */ }

  // oder Java 17 Records:
  record GreetingInput(String name, String msg) {}

  @QueryMapping
  public String greet(@Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  
* Argumente k√∂nnen mit Bean Validation validiert werden
* ```java
  class GreetingInput { @Size(min=5) private String name; private String msg; /* getter+setter... */ }

  @QueryMapping
  public String greet(@Valid @Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  
---

## Handler-Funktionen an Objekt-Typen

* <!-- .element: class="demo" --> Demo: Excerpt-Feld hinzuf√ºgen
  * <!-- .element: class="demo" --> `SchemaMapping` Implementieren !

---

### Handler-Funktionen an Objekt-Typen

* Felder, die an einem Java-Objekt definiert sind, die von einer Handler-Funktion
  zur√ºckgeliefert werden, werden automatisch per Reflektion von Spring-GraphQL abgefragt
  * Voraussetzung: Name des Java-Felder/getter-Methode entspricht Namen am GraphQL Schema
  * Beispiel: `body`- und `writtenBy`-Feld an der `Story`-Entity
* Wenn es kein Feld am Java-Objekt gibt, oder es sich anders verh√§lt, als von der GraphQL
  API erwartet, m√ºssen wir auch daf√ºr Handler-Funktionen schreiben
* (Felder, die an Java Objekten existieren, aber nicht in der GraphQL API k√∂nnen nie vom 
  Client abgefragt werden.)

---

### SchemaMapping

* Die Funktion wird dann mit `@SchemaMapping` annotiert
  * Name muss dem Namen des Feldes in der API entsprechen
  * Parameter bestimmt das `Source`-Objekt, auf dem das Feld ermittelt werden soll
  * Das Source-Objekt stammt aus einem vorherigen DataFetcher

* ```java
  @Controller
  class GraphQLController {
    @SchemaMapping
    public String excerpt(Story source, @Argument int maxLength) {
      return source.getBody().substring(0, maxLength);
    }
  }
  ```

* Wenn die als Parameter √ºbergebene Klasse nicht so hei√üt, wie im GraphQL Schema,
  kann mit `typename` der GraphQL-Typ explizit gesetzt werden

* ```java
  @SchemaMapping(typeName="Story")
  public String excerpt(StoryDto source) {
    // ...
  }
  ```

* `@QueryMapping`, `@SubscriptionMapping` und `@MutationMapping` sind nur Aliase f√ºr
  * `@SchemaMapping(typeName="Query")`
  * `@SchemaMapping(typeName="Mutation")`
  * `@SchemaMapping(typeName="Subscription")`

---

### √úbung: QueryMapping-Funktionen

* Kopiere bitte das (fertige) Schema aus `steps/01-schema` nach `publy-backend/src/main/resources/graphql` (bestehendes Schema √ºberschreiben)
* Erweitere die Klasse `nh.publy.backend.graphql.PublyGraphQLController`:
  * Implementiere zwei QueryMapping-Funktionen f√ºr die Root-Felder unserer API:
    * Eine Mapping-Funktion f√ºr `Query.stories` und f√ºr `Query.story(id: ID!)`
  * Du kannst in der Controller-Klasse das `StoryRepository` verwenden.
    * Darin sind Methoden zum Ermitteln der Stories aus der Datenbank enthalten.
* Folgende Queries sollten danach funktionieren (in GraphiQL http://localhost:8090 ausf√ºhren!):
  * ```graphql
      query {
        stories {
          id title body

          writtenBy { id profileImage }
        }
      }
      ```
  * ```graphql
      query {
        story(storyId: 1) {
          id title body

          writtenBy { id profileImage }
        }
      }
      ```
* Eine m√∂gliche L√∂sung findest Du in `steps/10_handler_function`

---

### Interaktiv: addComment-Mutation

  * <!-- .element: class="demo" --> Material aus material/17-mutation
  * <!-- .element: class="demo" --> Mit Payload als R√ºckgabe, ohne Union

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen

* Eine Story hat mehrere Kommentare:
* ```graphql
  type Comment {
      id: ID!

      story: Story!
      writtenBy: Member!
      content: String!
  }

  type Story {
    # ...
    comments: [Comment!]!
  }
  ```

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen

* Eingabe-Parameter werden mit einem `input-Type ausgedr√ºckt, der alle notwendigen Informationen entgegen nimmt
* ```graphql
  input AddCommentInput {
      storyId: ID!
      memberId: ID!
      content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
  ```
* ü§î Ist der R√ºckgabe-Typ hier so gut?
  * Was k√∂nnte problematisch sein oder werden?

---

### API Design von Mutations

* Wie ihr die Mutation designed ist nat√ºrlich Euch √ºberlassen, es gibt aber Best-Practices:
  * Anstatt n einzelne Argumente zu verwenden, **ein** Input-Objekt
    * Das Objekt hei√üt immer wie die Mutation mit `Input` am Ende
    * Das Argument hei√üt _immer_ `input`
  * Der R√ºckgabe-Typ sollte ebenfalls ein eigenes Objekt sein
    * Es hei√üt wie die Mutation mit `Payload` am Ende
    * Dieses Objekt enth√§lt dann das erzeugte neue Objekt
    * Ihr k√∂nnt sp√§ter diesen Typen um weitere Informationen, etwa zu Fehlern erweitern
      * Dazu sp√§ter mehr
* Dadurch ist die API einheitlich und man findet sich schnell zurecht
* Diese Regeln k√∂nntet ihr grunds√§tzlich auch f√ºr Queries und Subscriptions verwenden

---

### Eine Mutation, um Kommentare hinzuzuf√ºgen
<!-- .slide: class="left" -->
* Fertige Mutation
* ```graphql
  input AddCommentInput {
      storyId: ID!
      memberId: ID!
      content: String!
  }

  type AddCommentPayload {
    newComment: Comment!
  }

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentPayload!
  }
  ```
---
# Optimierungen
<!-- .slide: id="optimierungen" -->

--- 
### Neues Feature: User kommen aus einem Microservice

* <!-- .element: class="demo" --> Schema aus `steps/15_schema_mapping` kopieren
* <!-- .element: class="demo" --> SchemaMapping-Funktion f√ºr `Member.user` mit `userService.findUserWithId` implementieren
* <!-- .element: class="demo" --> SlowDown im UserService einstellen



### Ein einfacher Query...

* ü§î Was passiert, wenn wir folgenden Query ausf√ºhren:
* ```graphql
  query {
    stories {
      writtenBy { user { id email } }
    }
  }
  ```
* Wir haben sehr viele einzelne Calls zum Micro-Service üò®
* Wir haben doppelte Aufrufe zum Micro-Service üò± üò±

---

### Problem

<img src="images/dataloader-01.png" />

---

### DataLoader
<!-- .slide: id="dataloader" -->
* Ein `DataLoader` "verz√∂gert" das Laden von Daten

* <img src="images/dataloader-02.png" />

---

### DataLoader

* Ein `DataLoader` "verz√∂gert" das Laden von Daten
* In einem DataFetcher/Handler-Funktion √ºbergibst Du an einen DataLoader eine ID o.√§.
* Der DataLoader sammelt die IDs ein
* Wenn alle IDs eingesammelt wurden, wird die Implementierung des DataLoaders aufgerufen
* In der Implementierung bekommst Du alle IDs √ºbergeben und kannst einen optimierten Call machen
  * Zum Beispiel Zusammenfassung in SQL-Statements (`where ID in ...`)
* DataLoader sind ein allgemeines GraphQL-Konzept
  * Nicht in der Spec, aber de-facto Standard
* Java-Implementierung kommt aus dem [java-dataloader](https://github.com/graphql-java/java-dataloader)-Project
  * Wie bei `graphql-java` abstrahiert Spring for GraphQL davon
---

### Verwenden vom DataLoader

* Den DataLoader kannst Du dir in deine Handler-Funktionen √ºbergeben lassen
* Es handelt sich dabei um ein Interface mit zwei Typ-Parametern:
  * `Key`: Typ des Keys, den Du beim Verwenden an den DataLoader √ºbergeben willst
  * `Value`: Typ des Java-Objekts, das der DataLoader f√ºr einen Key zur√ºckliefert
* Die Handler-Funktion *muss* dann ein `CompletableFuture` zur√ºckliefern
* ```java
  public CompletableFuture<User> user(Member member, DataLoader<String, User> userLoader) {
    String userId = member.getUserId();  // userId ist in DB gespeichert

    return userLoader.load(userId); // Laden des Users wird verz√∂gert
  }
  ```

---


### Implementierung und Registrieren vom DataLoader

* Es gibt mehrere Wege
* In der `BatchLoaderRegistry` gibt es Hilfsfunktionen
* Die `BatchLoaderRegistry` steht als Spring Bean zur Verf√ºgung
* Mit `forTypePair` registrierst Du einen BatchLoader f√ºr ein Key-Value-Paar
* Die Methode erwartet eine Callback-Funktion:
  *  zwei Parameter: die Liste mit den Keys und das `BatchLoaderEnvironment`
  *  R√ºckgabe: die Liste mit den geladenen Objekten als [Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)
* ```java
  public PublyGraphQLController(/* ... */, BatchLoaderRegistry registry) {

    registry.forTypePair(String.class, User.class).registerBatchLoader(

      (List<String> keys, BatchLoaderEnvironment env) -> {
        // hier zum Beispiel DB-Aufruf oder REST-Aufruf
        // findUsers liefert Flux<User> zur√ºck.
        return userService.findUsers(keys);
      }
    );

  }
  ```
* Jeder Key wird nur einmal in die Liste eingef√ºgt, du bekommst also keine doppelten Keys
  * Selbst wenn Du also nicht _alle_ Objekte  mit _einem_ Request laden/ermitteln kannst,
    verhinderst Du immerhin doppeltes Laden
* Wichtig! Die Funktion muss die Objekte in derselben Reihenfolge zur√ºckliefern,
  in der die Keys √ºbergeben wurden.
  * Konnte f√ºr einen Key kein Objekt ermittelt werden, muss an der Stelle `null`
  zur√ºckgegeben werden

---

### MappedBatchLoader

* Der BatchLoader liefert eine _Liste_ von Objekten zur√ºck
* Die enthaltenen Objekte m√ºssen in derselben Menge und Reihenfolge wie die Keys zur√ºckgeliefert werden.
* Alternativ kann ein `MappedBatchLoader` verwendet werden, der ein [Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)-Objekt mit einer Map zur√ºckliefert
* Die Map enth√§lt dann Key-Value-Paare mit einem gelesenen Objekt jeweils f√ºr einen Key. Objekte, die nicht gefunden
  wurden werdenauch nicht in die Map aufgenommen.
* ```java
  public PublyGraphQLController(/*... */, BatchLoaderRegistry registry) {

    registry.forTypePair(String.class, User.class).registerMappedBatchLoader(

      (List<String> keys, BatchLoaderEnvironment env) -> {
        // zur√ºckgeben: Mono<Map<String, User>>
      }

    );
  }
  ```


---

### BatchMapping

* In einfachen F√§llen kann der `MappedBatchLoader` mit einer BatchMapping-Funktion implementiert werden
* Das ist eine Handler-Funktion, der automatisch eine Liste von Objekten √ºbergeben wird (zum Beispiel Liste von `Member`-Objekten)
* Die Handler-Funktion liefert dann entweder ein `Mono` mit einer `Map` oder ein `Flux` mit Objekten zur√ºck (wie vorher gesehen).
* Achtung! Darauf achten, dass `equals` und `hashCode`-Methoden in den Objekten, die als Keys verwendet werden, korrekt implementiert sind!
* ```java
  @Controller
  public class PublyGraphQLController {

    @BatchMapping
    public Flux<User> user(List<Member> member) {
      List<String> keys = member.stream().map(Member::getUserId).collect(Collectors.toList());

      return userService.findUsers(keys);
    }

    // -- oder: --

    @BatchMapping
    public Mono<Map<Member, User>> user(List<Member> member) {
      // ...
    }


    // BatchLoaderRegistry und SchemaMapping f√ºr User-Feld entfallen jetzt
  }
  ```

---
## Pagination

---
### Pagination

* GraphQL sagt nichts √ºber Pagination, Sortierungen, Filtern etc. aus
* Das was man braucht, muss man im Schema beschreiben
* ...und dann auch implementieren im Backend üò±
* <!-- .element: class="demo" --> Beispiel mit PageRequest

---
### GraphQL/Relay Cursor Spezifikation

* Es gibt eine [Spezifikation f√ºr Pagination](https://relay.dev/graphql/connections.htm)
* Die stammt aus der [Relay-Bibliothek](), wird aber von vielen genutzt
* Die Idee: man bekommt zu jedem Objekt einen Cursor geliefert
* Dann kann man bei jedem Request ausdr√ºcken, ob wieviele Objekte _vor_ oder _nach_ einem Cursor bekommen m√∂chte
* <!-- .element: class="demo" --> Demo im App-Projekt (oder https://publy.graphql.schule/) 

---
### Pagination mit Spring for GraphQL

* Seit der Version 3.1 von Spring Boot gibt es in Spring for GraphQL [Support for Pagination](https://docs.spring.io/spring-graphql/reference/request-execution.html#execution.pagination.types)
* Wenn ihr in Eurem Schema ein Query-Feld mit dieser Signatur habt:
* ```graphql
  type Query {
    stories(first:Int, after:String, last:Int, before:String): PostConnection!
  }
  ```
* ...dann generiert euch Spring for GraphQL zur Laufzeit die fehlenden GraphQL Typem im Schema
  * PostConnection, PostEdge, PageInfo
* In der QueryMapping-Funktion f√ºr `posts` k√∂nnt ihr einen Parameter vom Typ `ScrollSubrange` angeben
* Darin legt Spring for GraphQL die √ºbergebenen Parameter ( `first`, `last` etc ab)
* Aus diesem Objekt k√∂nnt ihr Euch u.a. eine [ScrollPosition](https://docs.spring.io/spring-data/rest/reference/data-commons/repositories/scrolling.html) von Spring Data geben lassen
* Damit k√∂nnt ihr dann einen Query in eurem Spring Data Repository ausf√ºhren, das ein `Window`-Objekt zur√ºckliefern muss
* Dieses `Window`-Objekt enth√§lt die gefundenen Ergebnisse
* Spring for GraphQL k√ºmmert sich dann darum, dass daf√ºr die `Edge`-Objekte und das `PageInfo`-Objekt erzeugt und zum Client zur√ºck gegeben wird

---
### Beispiel: Paginierung von Stories

* <!-- .element: class="demo" --> Schema anpassen
  * <!-- .element: class="demo" --> stories(first:Int, after:String, last:Int, before:String): StoryConnection
  * <!-- .element: class="demo" --> Story: createdAt String!
* <!-- .element: class="demo" --> QueryMapping fuer stories um ScrollSubrange erweitern 
---

---
### Sortierung

* Auch f√ºr Sortierung gibt es nichts fertiges
* ü§î Wie k√∂nnen wir das Ergebnis der Stories sortieren?
* <!-- .element: class="demo" --> Sortierung konfigurierbar machen

---

## Fehlerbehandlung
<!-- .slide: id="fehlerbehandlung" -->
* <!-- .element: class="demo" --> Beispiel: addComment mit "falschem" Kommentar
  * <!-- .element: class="demo" --> Wie sieht das Ergebnis aus?
  * <!-- .element: class="demo" --> Union-Type als Ergebnis

---

### Fehlerbehandlung

* Fehler, die nicht in einer Handler-Funktion verarbeitet werden, werden im `errors`-Feld zur√ºckgeliefert:
* ```json
  {
    "errors": [
      {
        "message": "addComment.input.content: Gr√∂√üe muss zwischen 5 und 2147483647 sein",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "INTERNAL_ERROR"
        }
      }
    ]
  }
  ```
* ```json
  {
    "errors": [
      {
        "message": "Unauthorized",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "UNAUTHORIZED"
        }
      }
    ]
  }
  ```

---

### Fehlerbehandlung

* Das `errors`-Objekt ist nur eingeschr√§nkt spezifiziert:
  * `message`: Fehlermeldung
  * `locations`: Auf welche Code-Stelle im Query bezieht sich der Fehler (wenn vorhanden)
  * `path`: Pfad zum Feld, das den Fehler verursacht hat (wenn vorhanden)
  * `extensions`: Propriet√§re Erweiterungen (`classification` kommt von Spring for GraphQL)
  * Keines dieser Felder ist im Schema beschrieben!
* `errors`-Objekt nur f√ºr "Request Errors" verwenden, wenn der Query gar nicht
  oder nicht vern√ºnftig ausgef√ºhrt werden kann
* Sonst lieber "fachliche" Fehler-Objekte zur√ºckliefern
  * Das ist insbesondere bei Mutations sinnvoll, da hier Fehler nicht unwahrscheinlich sind
  * Auch f√ºr andere Felder √ºberlegen, um API abw√§rtskompatibel zu halten

---

### Explizite R√ºckgabetypen

* Beispiel 1: **Query-Ergebnisse**
* ```graphql
  type Query {
    stories: [Story!]!
  }
  ```
* Was machen wir, wenn wir dem Ergebnis weitere Informationen hinzuf√ºgen wollen, z.B. wie viele Stories gibt es eigentlich?
* √Ñnderung am R√ºckgabetyp w√§re hier nicht abw√§rtskompatibel! üò¢
* ```graphql
  type StoriesPayload {
    stories: [Story!]!

    maxStories: Int!
  }

  type Query {
    stories: [Story!]!
  }
  ```
---

### Explizite R√ºckgabetypen

* Beispiel 2: **Behandlung von Fehlern**
* Hier k√∂nnen wir keine Informationen hinterlegen, warum das Anlegen eines Kommentars m√∂glicherweise nicht geklappt hat:
  * ```graphql
    type Mutation {
      addComment: [Comment!]!
    }
    ```
* Mit einem eigenen R√ºckgabe-Objekt k√∂nnen wir weitere Informationen hinzuf√ºgen:
  * ```graphql
    type AddCommentPayload {
      newComment: Comment
      errorMessage: String
    }

    type Mutation {
      addComment: AddCommentPayload!
    }
    ```
* Dieses Objekt k√∂nnen wir jederzeit erweitern, ohne das Clients angepasst werden m√ºssen.
---

### Explizite R√ºckgabetypen
* Fehler- und nicht-Fehlerfall k√∂nnen mit jeweils eigenen Typen ausgedr√ºckt werden.
* Zusammengefasst werden sie in einem `union`-Typen:
  * ```graphql
    type AddCommentSuccessPayload { newComment: Comment! }
    type AddCommentFailedPayload { errorMsg: String! }
    union AddCommentPayload = AddCommentSuccessPayload | AddCommentFailedPayload

    type Mutation {
      addComment(inpit: AddCommentInput!): AddCommentPayload!
    }
    ```
* Der Server liefert je nach Situationen einen der beiden Typen zur√ºck.
  * ```graphql
    mutation {
      addComment(input: {storyId: 1, memberId: 1, content: "Toll"}) {
        ... on AddCommentSuccessPayload {
          newComment { id content }
        }
        ... on AddCommentFailedPayload { errorMsg }
      }
    }
  ```
  * Achtung! Umstellung von type- auf union-Type im R√ºckgabewert ist nicht abw√§rtskompatibel!

---
### √úbung: Fehlerbehandlung mit Union Types

* **Stelle die `addComment`-Mutation auf einen Union-Type um**
* Vorbereitung:
  * L√∂sche die Mutation und den `AddCommentPayload`-Typen aus deinem Schema.
  * Kopiere die Anpassungen aus `material/30-error-handling/schema.graphqls` in dein Schema.
  * Falls Du mit der vorherigen √úbbung nicht fertig geworden bist, verwende als Basis den `PublyGraphQLController` aus `steps/20_dataloader`
* Passe die Implementierung der `addComment`-Mutation an
  * Deinen bestehenden Java-Typen f√ºr `AddCommentPayload` kannst Du in `AddCommentSuccessPayload` umbennen
  * Du brauchst einen neuen Java-Typen f√ºr `AddCommentFailedPayload`
  * Wenn beim Aufruf des `PublyDomainService` eine Exception fliegt, gib `AddCommentFailedPayload` zur√ºck mit einer Fehlermeldung
  * Sonst gib den neuen Kommentar in `AddCommentSuccessPayload` zur√ºck
* F√ºhre `addComment` aus und frag den neuen Kommentar bzw. die `errorMsg` ab
  * Um den Fehlerfall zu testen, kannst Du einen Kommentar speichern, der k√ºrzer als f√ºnf Zeichen ist.
* M√∂gliche L√∂sung: `steps/30_error_handling`



             </textarea
          >
        </section>

        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit GraphQL!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            <a
              href="https://www.linkedin.com/in/nils-hartmann-2a5738252/"
              target="_blank"
              >LinkedIn</a
            >
          </p>
          <p>
            <a
              href="https://www.xing.com/profile/Nils_Hartmann2/cv"
              target="_blank"
              >Xing</a
            >
          </p>
          <p>
            Mastodon:
            <a href="https://norden.social/@nilshartmann" target="_blank"
              >@nilshartmann@norden.social
            </a>
          </p>

          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>
    <script src="revealjs/reveal.js/dist/reveal.js"></script>
    <script src="revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="revealjs/config.js"></script>
  </body>
</html>
