<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Spring GraphQL Workshop</title>

    <link rel="stylesheet" href="revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="revealjs/styles.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>Spring GraphQL Workshop</b>
          </h2>

          <h3>
            <span class="transparent-bg"> 20. April 2022 </span>
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: 2022_04_20_spring-graphql.html</span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://reacttraining.dev">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>
    ## Die Beispiel-Anwendung

    ---
    ## Beispiel: Tooling mit GraphiQL und IntelliJ IDEA

    ---
    ## Architektur Beispiel-Anwendung

    ### todo !!!!!!!!!!!!!
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>
# Die GraphQL Abfrage-Sprache
---

### Sprache, um **Felder** aus einem **Objekt-Graphen** abzufragen

```graphql
  query {
    story {
      id title writtenBy {
        id user { name }
      }
    }
  }

---

### Felder können **Argumente** haben

<pre><code class="graphql">
  query {
    story(storyId: 5) {
      id title writtenBy {
        id user { name }
      }
    }
  }
</code></pre>

---

### Die **Antwort** sieht immer so aus, wie die Abfrage

<img src="images/query-antwort.png" />

---

### Operation-Type

Ausgeführt werden **Operationen**.
Der **Operation-Type** beschreibt, was in der Anfrage getan werden soll

* **query**: Daten lesen (Default-Operation, Schlüsselwort "query" kann weggelassen werden)
* **mutation**: Daten verändern
* **subscription**: Daten vom Server bekommen, sobald sie erzeugt wurden (ähnlich wie Events)

---


### Operation-Type

Der Operation-Type bestimmt auch den Einstiegspunkt in den Objekt-Graphen

<img src="images/einstiegspunkte.png" />

---

### Namen von Operationen

*Operationen können **Namen** haben.
* Das ist vor allem für Debugging und Code-Generatoren relevant

<pre class="fragment"><code class="graphql">
query NewestStory {
    story {
      id
      title
    }
}
</code></pre>

---

### Fragmente

Mit einem **Fragment** beschreibst Du eine wiederverwendbare Menge von Feldern
<pre><code class="graphql">
fragment BaseMember on Member {
    id joined
    user { is username }
}

query {
    story {
      writtenBy { ...BaseMember }

      reactions {
        givenBy { ...BaseMember }
      }
    }
}
</code></pre>

---

### Union-Typen

Ein **Union-Type** kann mehr als einen Typ zurückliefern:

<pre><code class="graphql">
mutation  addComment
    (input: { storyId: "1", content: "..." }) {

    ...on AddCommentSuccessPayload {
      newComment { id }
    }

    ...on AddCommentFailurePayload {
      errorMessage
    }
}
</code></pre>

---
### Interfaces

Ein Interface erzwingt gemeinsame Felder an den Objekten, die das Interface implementieren (ähnlich
    wie in Java mit Methoden)

* Beispiel: `id` und `createdAt` sind am `Node`-Interface definiert

<pre><code class="graphql">
query {
    node(id: "...") {

      id
      createdAt

      ...on Story { title body }
      ...on Comment { content }
    }
}
</code></pre>


---

### Variablen

* Queries können **Variablen** haben.
* Variablen müssen im Query deklariert werden
* Werte für Variablen werden in einem eigenen JSON-Objekt an den Server geschickt

<pre class="fragment"><code class="graphql">query ($storyId: ID!) {
    story(id: $storyId) {
      id
      title body
    }
}
</code></pre>
 
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>
# Das GraphQL Schema

---

### Das GraphQL Schema

* GraphQL APIs müssen in einem Schema beschrieben werden.
* In dem Schema werden Objekte (Typen) mit Feldern beschrieben.
* Das Schema selbst ist zur Laufzeit mit einem _Introspection Query_ abfragbar
* Je nach Framework gibt's unterschiedliche Möglichkeiten, das Schema zu definieren
  * **Schema-first**: erst Schema beschreiben, dann implementieren
  * **Code-first**: Schema wird aus (Java-)Code generiert
  * Java-Frameworks verwenden i.d.R. Schema-first (bis auf MicroProfile GraphQL)  

---

### Beschreibung des Schemas

* Mit der [Schema Definition Language](https://graphql.org/learn/schema/) 
* Per [Java API](https://www.graphql-java.com/documentation/schema) in
  GraphQL-Java 
* In der Regel wird die **SDL** verwendet 
  * Java API nur für _Type Resolver_ und eigene Skalare

---

### Die SDL

* <!-- .element: class="demo" --> Demo: Schema-Definition 
* ping-Feld
* Argument!
* Rückgabewert-String

---

### Die SDL

Beschreibung eines *Objekt Types*

<pre><code class="graphql">
  type Story {
    id: ID!

    title: String!
    body: String!
  }
</code></pre>

* Beschrieben werden **Felder** mit **Return Types**
* Ein Ausrufezeichen zeigt an, dass das Feld nicht _nullable_ ist

* Dokumentation mit Markdown und drei doppelten Anführungszeichen
* Kommentare mit Hash-Zeichen
  * Dokumentation ist Bestandteil der API, Kommentare nicht

<pre class="fragment"><code class="graphql">
  """
  A `Story` is the main object in our service.
  """
  type Story {
    """Identifies this object"""
    id: ID!

    # todo: tags-Feld implementieren!
  }
  
</code></pre>

---

## Skalare Typen

* Skalare Typen entsprechen primitiven Typen in Java
  * Sind die Enden im Objekt-Graphen
* Standard-Typen: ID, String, Boolean, Int, Float
  * ID wird als String gelesen und geschrieben, soll aber nicht interpretiert werden


<pre class="fragment"><code class="graphql">
  type Member {
    id: ID!

    username: String!

    # no exclamation mark: can be null
    likes: Int

    amount: Float!

    activeMember: Boolean
}
</code></pre>
  

* Man kann eigene skalare Typen bauen
---

### Aufzählungstypen (enum)

* Wie in Java


<pre><code class="graphql">
  enum ReactionType {
    like,
    laugh,
    thumbUp
  }
</code></pre>

---

### Referenzen

* Referenzen auf andere Objekt-Typen

<pre class="fragment"><code class="graphql">
  type Member {
    # ...
  }

  type Comment {
    # ...
  }

  type Story {
    """Reference to the Member that has written this Story"""
    writtenBy: Member!

    comments: [Comment!]!

  }
</code></pre>

---

### Argumente

* Felder können Argumente haben
  * Solche Felder werden auch _Methoden_ genannt
* Die Felder mit ihren Namen und Typen müssen in der API definiert werden
  * Namen sind entscheidend (wie "named arguments" in Kotlin), nicht Reihenfolge (wie in Java)
* Argumente können Default-Werte haben
* Achtung! Argumente dürfen keine Objekt-Typen sein!  


<pre class="fragment"><code class="graphql">
type Story {
  # Mandatory argument maxLength, defaults to 20
  #  if not specified by the client
  excerpt(maxLength: Int! = 20): String!


}  
</code></pre>

---

### Root-Typen

* Root-Typen bilden den Einstiegspunkt für Queries in den Objekt-Graphen
* Root-Typen sind **Query**, **Mutation** und **Subscription**
  * **Query** ist Pflicht, die beiden anderen Typen optional
* Syntax und Verhalten genauso wie bei Objekt-Typen
* Felder an den Root-Typen werden auch **Root-Felder** genannt


<pre class="fragment"><code class="graphql">
  type Query {
    """Returns a List of all stories"""
    stories: [Story!]!

    """Returns a story by its ID or null"""
    story(id: ID!): Story
  }

  type Mutation {
    addComment(storyId: ID!, memberId: ID!, content: String!): Comment!
  }
</code></pre>

---

### Input-Typen

* Objekt-Typen können nicht als Argument an ein Feld übergeben
* Als Argumente an Feldern können nur skalare Typen, Enums und Input-Typen übergeben werden.
* Ein Input-Type wird mit `input` definiert, sieht ansonsten aus wie ein Objekt-Type
  * Ein Input-Type darf keine Objekt-Typen referenzieren


<pre class="fragment"><code class="graphql">
  input AddCommentInput {
    storyId: ID!
    memberId: ID!
    content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
</code></pre>

---

### Union Types

* Union Types bilden eine Menge von anderen Typen
* Ein Feld kann ein Typen aus dieser Menge zurückliefern ("A _oder_ B")


<pre class="fragment"><code class="graphql">
  type AddCommentSuccess { newComment: Comment! }
  type AddCommentFailed { errorMessage: String! }

  union AddCommentResult = AddCommentSuccess | AddCommentFailed

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentResult!
  }

</code></pre>

---

### Interfaces

* Mit einem Interface wird erzwungen, dass Objekte über gleiche Felder verfügen
  * Vergleichbar mit Interfaces in Java


<pre class="fragment"><code class="graphql">
  interface Node {
    id: ID!
  }

  type Story implements Node {
    id: ID!  # Feld aus Interface

    title: String! # Weitere Story-Felder
  }

  type Comment implements Node {
    id: ID! 

    content: String!
  }

  type Query {
    node(id: ID!): Node # Liefert Story oder Comment zurück
  }
</code></pre>

---

### Schema-Evolution

* In GraphQL gibt es nur _eine Version_ der API (kein `/api/v1`, `/api/v2`)
* Das Schema kann jederzeit erweitert werden
  * Clients fragen explizit Felder ab, d.h. durch neue Felder werden sie nicht beeinträchtigt
* Man kann Felder mit `deprecated` markieren, um anzuzeigen, dass sie nicht genutzt werden sollen  

<pre class="fragment"><code class="graphql">
  type Query {
    # Ausgangspunkt 
    getStoryById(id: ID!): Story
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  type Query {
    getStoryById(id: ID!): Story

    # Neues Feld, beeinträchtigt bestehenden Client nicht
    stories: [Story!]!
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  type Query {
    getStoryById(id: ID!): Story @deprecated("Use story instead")
    story(id: ID!): Story

    stories: [Story!]!
  }
</code></pre>

---

### Das Schema in Spring GraphQL

* Das Schema wird in Schema-Dateien mit der Endung `.graphqls` abgelegt
  * Verzeichnis: `main/resources/graphql`
* Spring Boot sammelt alle Schema-Dateien ein und erzeugt ein Schema daraus
* Typen können erweitert werden


<pre class="fragment"><code class="graphql">
  # story.graphqls
  extend type Query {
    story(id: ID!): Story
  }

  # comment.graphqls
  extend type Query {
    comment(id: ID): Comment
  }
</code></pre>

---

### 

### Übung: Schema Beschreiben

* Lege die Datei `resources/graphql/publy.graphqls` an und beschreibe darin eine API, die folgende Objekt-Typen enthält:
  * **Member** mit `id` und `profileImage`
  * **Story** mit `id`, `title` und `body` und einer Referenz (`writtenBy`) auf den Member
  * Alle Felder in den beiden Typen sind Pflicht (non-nullable), das `id`-Feld ist vom Typ `ID` alle anderen Strings
* Lege den Query-Typen mit folgenden Feldern an:
  * `stories`: Liefert eine Liste der `Story`-Objekte zurück. Nicht nullable.
  * `story`: Liefert eine einzelne Story zurück. Das Feld soll ein Argument haben: `storyId`. Das Feld kann `null` zurückgeben
* Füge für ein oder zwei Felder oder Typen Dokumentation hinzu
* Die Implementierung für die API machen wir später! Du musst also nichts programmieren.
* Sieh dir das API-Schema in GraphiQL an (http://localhost:8090).
  * Prüfe, ob Code Completion funktioniert und ob die Dokumentation im "Docs"-Tab findest
  * Wenn Du Änderungen an der `graphqls`-Datei gemacht hast, musst Du die Anwendung neu bauen, und in GraphiQL
    die Seite im Browser neu laden.
  * Du kannst mal probieren, was passiert, wenn Du einen `stories` bzw `story`-Query ausführst.    
    * Eine gültige ID für eine Story ist z.B. `1`


---

# Verarbeitung von GraphQL Queries

---

### Ablauf eines Queries

1. Query kommt an (in der Regel über einen HTTP POST Request)
2. Query wird geparst und validiert
3. Ungültige Queries werden abgewiesen (`errors`-Feld in der Antwort)
4. Für jedes Feld wird ein `DataFetcher` aufgerufen, der verantwortlich dafür ist, die Daten für das jeweilige Feld zu liefern
5. Die Ergebnisse der DataFetcher werden validiert (insb. hinsichtlich der Typen)
6. Das Ergebnis wird an den Client zurückgesendet (`data`-Feld in der Antwort)


* <!-- .element: class="note" --> Unsere Aufgabe ist es, die DataFetcher zu implementieren

---

### DataFetcher

* Zentrales Interface in GraphQL-Java: Ermitteln die Daten für _ein_ Feld eines Queries
  * Zum Beispiel für das Feld `Query.story` oder `Story.title`
  * Hier nur zur Kenntnis, in Spring GraphQL abstrahiert
  * In anderen GraphQL Frameworks auch `Resolver` genannt

```java fragment  
  interface DataFetcher<T> {
    T get(DataFetchingEnvironment environment); 
  }  
```  

* Die DataFetcher werden im **RuntimeWiring** registriert

---

## GraphQL Java Architektur


<img src="images/graphql-java-architektur.png" />
---

## Spring GraphQL

* [Spring GraphQL](https://spring.io/projects/spring-graphql) bietet eine Abstraktion von GraphQL-Java an
* Automatische Konfiguration des RuntimeWirings
* HTTP-Endpunkt für Requests und Subscriptions automatisch
* GraphiQL integration per Property
* Gewohntes Spring-Programmiermodell mit Annotationen etc.
* Integration in Spring Stack (z.B. Bean Validation, Security)
* [`spring-boot-starter-graphql`](https://docs.spring.io/spring-boot/docs/2.7.0-SNAPSHOT/reference/htmlsingle/#web.graphql) für Spring Boot

---

## Spring GraphQL

* <!-- .element: class="demo" --> Demo: Handler-Funktionen mit `ping`-Feld
* Query-Mapping!
* Argumente!

---

## Handler-Funktionen


* Anstatt `DataFetcher` werden `Handler-Funktionen` an `Controller`-Klassen implementiert
  * Vorsichtig vergleichbar mit `@RequestMapping` 

  ```java fragment  
    @Controller
    public StoryController {

      @QueryMapping
      public List<Story> stories() { /* ... */ }

    }
  ```
  
  * Handler-Funktionen für Felder am Query-Typen werden mit `@QueryMapping` annotiert
    * Mutations: `@MutationMapping`, Subscription: `@SubscriptionMapping`
  * Der Name der Methode entspricht dem Namen des Feldes des entsprechenden Root-Typen (oder explizit mit `value` setzen)

---

### Environment-Objekte

* In GraphQL-Java und Spring-GraphQL werden häufig `Environment`-Objekte verwendet
  * Zum Beispiel: `DataFetchingEnvironment`, `DataLoaderEnvironment`, `TypeResolutionEnvironment`
* Dabei handelt es sich um Objekte, die Informationen über den aktuellen Query, bzw. die aktuelle
  Ausführungsumgebung enthalten
  * Anstatt meherere Methoden-Parameter zu verwenden  
  * In anderen Frameworks wären das zum Beispiel `Context` oder `Info`-Klassen
* Das `DataFetchingEnvironment` kannst Du als Parameter an Handler-Funktionen hinzufügen
  * Hierüber bekommst Du z.B. Informationen über den aktuellen Query und Zugriff auf das Schema

---

### Context

* Beim Ausführen jedes Queries wird ein Context-Objekt erzeugt, dass Du z.B. über das `DataFetchingEnvironment`
  abfragen und befüllen kannst.
* Dabei handelt es sich um ein Objekt mit Key-Value-Paaren
* Häufig wird es zum Beispiel für Security-Informationen oder zum reinreichen von Services in die DataFetcher verwendet
* Ich denke, in der Spring-Welt mit Dependency-Injection spielt es eher keine Rolle, deswegen werden wir uns das nicht ansehen


---

### Argumente


* Auf einzelne Argumente kann mit `@Argument` zugegriffen werden
  * Der Name des Java-Parameters muss dem Namen des Argumentes entsprechen 
  * (oder explizit angeben)

```java fragment  
  @QueryMapping
  public Story story(@Argument String id) { /* ... */ }
```

* Für **Input-Types** kann ein Java POJO angegeben werden

```java fragment  
  static class CommentInput { String storyId; String memberId; String content };

  @MutationMapping
  public Comment addComment(@Argument CommentInput input) { /* ... */ }
```
      
* Weitere Möglichkeiten:
  * `@Arguments` um _alle_ Argumente in _einem_ Java Objekt zu bekommen
  * `@ProjectedPayload` an einem Interface, um Argumente gleichen Namens zu erhalten

```java fragment  
  @ProjectedPayload
  interface CommentInput {
    String getStoryId();
    String getMemberId();
    String getContent();
  }
  
  @MutationMapping
  public Comment addComment(@Argument CommentInput input) { /* ... */ }
```

---

## Übung: Handler-Funktionen

_Implementiere zwei Handler-Funktionen_

* Eine Handler-Funktion `Query.stories` und für `Query.story(id: ID!)`
* Lege dazu eine neue Controller-Klasse an (`PublyGraphQLController`)
* Folgende Queries sollten danach funktionieren:

<pre class="fragment"><code class="graphql">
  query {
    stories {
      id
      title
      body
     
      writtenBy {
        id
        profileImage
      }
    }
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  query {
    story(storyId: 1) {
      id
      title
      body
     
      writtenBy {
        id
        profileImage
      }
    }
  }
</code></pre>

---

## Handler-Funktionen an Objekt-Typen

* <!-- .element: class="demo" --> Excerpt-Feld hinzufügen
* <!-- .element: class="demo" --> `SchemaMapping` Implementieren !

---

### Handler-Funktionen an Objekt-Typen

* Felder, die an einem Java-Objekt definiert sind, die von einer Handler-Funktion
  zurückgeliefert werden, werden automatisch per Reflektion von Spring-GraphQL abgefragt
  * Voraussetzung: Name des Java-Felder/getter-Methode entspricht Namen am GraphQL Schema
  * Beispiel: `body`- und `writtenBy`-Feld an der `Story`-Entity
* Wenn es kein Feld am Java-Objekt gibt, oder es sich anders verhält, als von der GraphQL
  API erwartet, müssen wir auch dafür Handler-Funktionen schreiben
* (Felder, die an Java Objekten existieren, aber nicht in der GraphQL API können nie vom 
  Client abgefragt werden.)

---

### SchemaMapping

* Die Funktion wird dann mit `@SchemaMapping` annotiert
  * Name muss dem Namen des Feldes in der API entsprechen
  * Parameter bestimmt das `Source`-Objekt, auf dem das Feld ermittelt werden soll
  * Das Source-Objekt stammt aus einem vorherigen DataFetcher

```java fragment  
@Controller
class GraphQLController {
  @SchemaMapping  
  public String excerpt(Story source, @Argument int maxLength) {
    return source.getBody().substring(0, maxLength);
  }

}
```

* Wenn die als Parameter übergebene Klasse nicht so heißt, wie im GraphQL Schema,
  kann mit `typename` der Typ explizit gesetzt werden

```java fragment  
@SchemaMapping(typeName="Story")
public String excerpt(StoryDto source) {
  // ...
}
```

* `@QueryMapping` und `@MutationMapping` sind nur Aliase für 
  * `@SchemaMapping(typeName="Query")` bzw.
  * `@SchemaMapping(typeName="Mutation")`

  
---

## Asynchrone Handler-Funktionen

* <!-- .element: class="demo" --> Instrumentation hinzufügen
* <!-- .element: class="demo" --> excerpt-Feld slowdown aktivieren
* <!-- .element: class="demo" --> stories abfragen und Report auswerten
* <!-- .element: class="demo" --> CompletableFuture


---

### Asynchrone Handler-Funktionen

* Handler-Funktionen werden grundsätzlich nacheinander ausgeführt 
* Handler-Funktionen können aber `CompletableFuture`, `Flux` oder `Mono`-Objekte zurückliefern
* Dann werden mehrere Handler-Funktionen parallel ausgeführt

```java fragment  
  class DomainService {
    @Async
    CompletableFuture<User> determineExcerpt(Story story) {
      // long running task...
    }
  }

  @Controller
  public class GraphQLController {
    @Autowired DomainService domainService;

    @SchemaMapping
    public CompletableFuture<String> story(Story story) {
      return domainService.determineExcerpt(story); // asynchron bzw. reaktiv
    }
  }
```

---

### Übung: Zugriff auf externen Service

* Wir erweitern den Member-Typen um das User-Objekt:

<pre class="fragment"><code class="graphql">
  type User {
    id: ID!
    username: String
  }

  type Member {
    # ...
    user: User
  }
</code></pre>

* Die `Member`-Klasse hat aber keine Referenz auf den User (nur dessen Id)
* Der User kommt aus dem `UserService` (externer Micro-Service)
* 🤔 Was müssen wir tun, um den User zu ermitteln? 🤔

---

### Übung: Schema-Mapping 

* Ergänze das Schema
  * Neuer Type `User`, Felder: `id` (ID), `name` (String) und `email` (String). Alle non-nullable. 
  * Erweiter den `Member`-Typen um das Feld `user` (Type: `User`, nullable).
* Führe den untenstehenden Query aus. Was kommt für `user` zurück und warum?  
* Implementiere die Schema-Mapping-Funktion für das Feld
  * Die Schema-Mapping-Funktion soll asynchron funktionieren
  * Der `UserService` ist bereits implementiert
* Der folgende Query sollte dann einen User zurückliefern:

<pre class="fragment"><code class="graphql">
  query {
    story(storyId: 1) {
      id 
      writtenBy {
        id
        user {
          id username  email
        }
      }
    }
  }
</code></pre>

---

## Optimierungen

---

### DataLoader

* Was passiert, wenn wir folgenden Query ausführen:

<pre class="fragment"><code class="graphql">
  query {
    stories {
      writtenBy { user { id email } }
    }
  }
</code></pre>


* Wir haben sehr viele einzelne Calls zum Micro-Service 😨
* Wir haben doppelte Aufrufe zum Micro-Service 😱 😱

---

### DataLoader

* Ein `DataLoader` "verzögert" das Laden von Daten
* In einem DataFetcher/Handler-Funktion übergibst Du an einen DataLoader eine ID o.ä.
* Der DataLoader sammelt die IDs ein
* Wenn alle IDs eingesammelt wurden, wird die Implementierung des DataLoaders aufgerufen
* In der Implementierung bekommst Du alle IDs übergeben und kannst einen optimierten Call machen
  * Zum Beispiel Zusammenfassung in SQL-Statements (`where ID in ...`)
  * Du bekommmst jede ID auch nur einmal übergeben

---

### Verwenden vom DataLoader

* Den DataLoader kannst Du dir in deine Handler-Funktionen übergebenlassen
* Es handelt sich dabei um ein Interface mit zwei Typ-Parametern:
  * `Key`: Typ des Keys, den Du beim Verwenden an den DataLoader übergeben willst
  * `Value`: Typ des Java-Objekts, das der DataLoader für einen Key zurückliefert


```java fragment
public CompletableFuture<User> user(Member member, DataLoader<String, User> userLoader) {
  String userId = member.getUserId();  // UserId ist in DB gespeichert

  return userLoader.load(userId); // Laden des Users wird verzögert
}
```

---


### Implementierung und Registrieren vom DataLoader

* Es gibt mehrere Wege
* In der `BatchLoaderRegistry` gibt es Hilfsfunktionen
* Die `BatchLoaderRegistry` steht als Spring Bean zur Verfügung
* Mit `forTypePair` registrierst Du einen BatchLoader für ein Key-Value-Paar
* Die Methode erwartet eine Callback-Funktion:
*  zwei Parameter: die Liste mit den Keys und das `BatchLoaderEnvironment`
*  Rückgabe: die Liste mit den geladenen Objekten als Flux


```java fragment  
public PublyGraphQLController(/* ... */, BatchLoaderRegistry registry) {

  registry.forTypePair(String.class, User.class).registerBatchLoader(

    (List<String> keys, BatchLoaderEnvironment env) -> {
      // findUsers liefert Flux<User> zurück. 
      return userService.findUsers(keys);
    }
  );

}
```
 
* Jeder Key wird nur einmal in die Liste eingefügt, du bekommst also keine doppelten Keys
  * Selbst wenn Du also nicht _alle_ Objekte  mit _einem_ Request laden/ermitteln kannst,
    verhinderst Du immerhin doppeltes Laden
* Wichtig! Die Funktion muss die Objekte in derselben Reihenfolge zurückliefern,
  in der die Keys übergeben wurden.
  * Konnte für einen Key kein Objekt ermittelt werden, muss an der Stelle `null`
  zurückgegeben werden

---

### MappedBatchLoader

* Der BatchLoader liefert eine _Liste_ von Objekten zurück
* Die enthaltenen Objekte müssen in derselben Menge und Reihenfolge wie die Keys zurückgeliefert werden.
* Alternativ kann ein `MappedBatchLoader` verwendet werden, der ein Mono-Objekt mit einer Map zurückliefert
* Die Map enthält dann Key-Value-Paare mit einem gelesenen Objekt jeweils für einen Key. Objekte, die nicht gefunden
  wurden werden auch nicht in die Map aufgenommen.

```java fragment  
public PublyGraphQLController(/*... */, BatchLoaderRegistry registry) {

  registry.forTypePair(String.class, User.class).registerMappedBatchLoader(

    (List<String> keys, BatchLoaderEnvironment env) -> {
      // zurückgeben: Mono<Map<String, User>>
    }

  );
}
```


---

### BatchMapping

* In einfachen Fällen kann der MappedBatchLoader mit einer BatchMapping-Funktion implementiert werden
* Das ist eine Handler-Funktion, der automatisch eine Liste von Objekten übergeben wird (zum Beispiel Liste von Member-Objekten)
* Die Handler-Funktion liefert dann entweder ein Mono mit einer Map oder ein Flux mit Objekten zurück (wie vorher gesehen).
* Achtung! Darauf achten, dass `equals` und `hashCode`-Methoden in den Objekten, die als Keys verwendet werden, korrekt implementiert sind!

```java fragment  
@Controller
public class PublyGraphQLController {

  @BatchMapping
  public Flux<User> user(List<Member> member) {
    List<String> keys = member.stream().map(Member::getUserId).collect(Collectors.toList());

    return userService.findUsers(keys);
  }

  // -- oder: --

  @BatchMapping
  public Mono<Map<Member, User>> user(List<Member> member) {
    // ...
  }


  // BatchLoaderRegistry und SchemaMapping für User-Feld entfallen jetzt
}
```

---

### DataFetchingFieldSelectionSet

* Das `DataFetchingFieldSelectionSet` enthält eine Liste aller Felder, die im aktuellen Query abgefragt sind
* Hiermit kannst Du weitere Optimierungen der Query-Verarbeitung vornehmen, zum Beispiel optimale
  SQL-Queries generieren
* Das `DataFetchingFieldSelectionSet` kannst Du an deine Handler-Funktionen übergeben lassen.

```java fragment  
@QueryMapping List<Story> stories(DataFetchingFieldSelectionSet selectionSet) {

  if (s.contains("comments") ) {
    // SQL Statement mit JOIN auf Comment-Tabelle
    return ...;
  }

  // SQL Statement nur mit Stories
  return ...;
  
}  
```
  
---


### Ausblick: Security

* Wie üblich Spring Security verwenden
* Überlegung: wo wird GraphQL API abgesichert?
  * /graphql-Endpunkt absichern
  * und/oder einzelne Handler-Funktionen mit `@PreAuthorize` absichern
  * und/oder Domain-Layer absichern mit `@PreAuthorize` absichern

* HandlerFunktionen können mit `@AuthenticationPrincipal` sich den aktuellen Principal übergeben lassen

```java fragment  
public Story addStory(@Argument AddStoryInput input, @AuthenticationPrincipal PublyUser user) {
  Long storyWrittenById = user.getId();

  return domainService.addStory(storyWrittenById, input.getTitle(), input.getBody());
})  
```


---

### Test

---

### Ende
  

  


             </textarea
          >
        </section>
      </div>
    </div>
    <script src="revealjs/reveal.js/dist/reveal.js"></script>
    <script src="revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="revealjs/config.js"></script>
  </body>
</html>
