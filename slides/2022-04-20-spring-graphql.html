<html lang="de">
  <!DOCTYPE html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Spring GraphQL Workshop</title>

    <link rel="stylesheet" href="revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="revealjs/styles.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>Spring GraphQL Workshop</b>
          </h2>

          <h3>
            <span class="transparent-bg">20. April 2022 </span>
          </h3>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank"
                >Nils Hartmann</a
              >
              |
              <a href="https://twitter.com/nilshartmann" target="_blank"
                >@nilshartmann</a
              >
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: slides/2022_04_20_spring-graphql.html</span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
            /
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
          <p>
            <em
              >Freiberuflicher Software-Entwickler, Berater und Trainer aus
              Hamburg</em
            >
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://nilshartmann.net/workshops"
                  >Schulungen und Workshops</a
                >
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <section data-markdown>
          <textarea data-template>

## Agenda

* Teil 1: GraphQL
  * Was ist GraphQL?
  * Die Abfragesprache
  * APIs beschreiben

  
* Teil 2: Spring GraphQL  
  * GraphQL APIs mit Spring-GraphQL implementieren
  * Optimierungen
  * Testen

---

## Zeitplan

* 12:30 bis 17:00
* Zwischendurch Pausen ‚òïÔ∏è üò¥

---


## Grunds√§tzliches

* **Jederzeit:** Fragen und Diskussionen!
* Motto: Es gibt keine dummen Fragen!
* Bemerkbar machen per Audio, Chat oder in Teams "Hand erheben"
* <img width="30%" src="images/teams-hand-heben.png" />
* Bonuspunkte f√ºr eingeschaltetes Video ü•∞
* Ich zeige viel direkt im Editor, aber ihr k√∂nnt die Slides als Referenz benutzen
* Wir machen zwischendurch √úbungen, in denen ihr selbst programmieren k√∂nnt

---

# GraphQL
  
---

# GraphQL


_"GraphQL is a **query language for APIs** and a runtime for fulfilling those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a **runtime for fulfilling** those queries with your existing data"_ ([https://graphql.org](https://graphql.org))

---
<!-- .slide: data-transition="none" -->

# GraphQL

_"GraphQL is a query language for APIs and a runtime for fulfilling those queries with **your existing data**"_ ([https://graphql.org](https://graphql.org))

---

## Spezifikation

* https://spec.graphql.org/
* Umfasst:
  * Query Sprache und -Ausf√ºhrung
  * Schema Definition Language
* Kein fertiges Produkt, keine fertige Bibliothek
   * Es gibt Bibliotheken, die dir helfen, GraphQL APIs zu implementieren und bereitzustellen
   * Die abgefragten Daten m√ºssen wir selbst ermitteln
   * GraphQL macht keine Aussage dar√ºber, wo diese Daten herkommen (lokal, Datenbank, Micro-Service, ...)

---

## Die Beispiel-Anwendung

<img style="border: 1px solid grey" src="images/publy-screenshot.png" />

---

## Beispiel: GraphQL Tooling

* <!-- .element: class="demo" --> IntelliJ IDEA
  * <!-- .element: class="demo" --> graphql-Extension (hello.graphql)
  * <!-- .element: class="demo" --> GraphQL.md im publy-Verzeichnis
  * <!-- .element: class="demo" --> language=GraphQL in einer leeren Java-Datei

* <!-- .element: class="demo" --> TypeScript
  * <!-- .element: class="demo" --> publy-frontend, npm run codegen:watch
  * <!-- .element: class="demo" --> StoryPage.query.graphql zeigen und story-Feld entfernen

---

# Die GraphQL Abfrage-Sprache

---

### Sprache, um **Felder** aus einem **Objekt-Graphen** abzufragen

```graphql
  query {
    story {
      id title writtenBy {
        id user { name }
      }
    }
  }

---

### Felder k√∂nnen **Argumente** haben

<pre><code class="graphql">
  query {
    story(storyId: 5) {
      id title writtenBy {
        id user { name }
      }
    }
  }
</code></pre>

---

### Die **Antwort** sieht immer so aus, wie die Abfrage

<img src="images/query-antwort.png" />

---

### Operation-Type

Ausgef√ºhrt werden **Operationen**.
Der **Operation-Type** beschreibt, was in der Anfrage getan werden soll

* **query**: Daten lesen (Default-Operation, Schl√ºsselwort "query" kann weggelassen werden)
* **mutation**: Daten ver√§ndern
* **subscription**: Daten vom Server bekommen, sobald sie erzeugt wurden (√§hnlich wie Events)

---


### Operation-Type

Der Operation-Type bestimmt auch den Einstiegspunkt in den Objekt-Graphen

<img src="images/einstiegspunkte.png" />

---

### Namen von Operationen

* Operationen k√∂nnen **Namen** haben.
* Das ist vor allem f√ºr Debugging und Code-Generatoren relevant

<pre class="fragment"><code class="graphql">
query NewestStory {
    story {
      id
      title
    }
}
</code></pre>

---

### Fragmente

Mit einem **Fragment** beschreibst Du eine wiederverwendbare Menge von Feldern
<pre><code class="graphql">
fragment BaseMember on Member {
    id joined
    user { is username }
}

query {
    story {
      writtenBy { ...BaseMember }

      reactions {
        givenBy { ...BaseMember }
      }
    }
}
</code></pre>

---

### Union-Typen

Ein **Union-Type** kann mehr als einen Typ zur√ºckliefern:

<pre><code class="graphql">
mutation  addComment
    (input: { storyId: "1", content: "..." }) {

    ...on AddCommentSuccessPayload {
      newComment { id }
    }

    ...on AddCommentFailurePayload {
      errorMessage
    }
}
</code></pre>

---
### Interfaces

Ein Interface erzwingt gemeinsame Felder an den Objekten, die das Interface implementieren (√§hnlich
    wie in Java mit Methoden)

* Beispiel: `id` und `createdAt` sind am `Node`-Interface definiert

<pre><code class="graphql">
query {
    node(id: "...") {

      id
      createdAt

      ...on Story { title body }
      ...on Comment { content }
    }
}
</code></pre>


---

### Variablen

* Queries k√∂nnen **Variablen** haben.
* Variablen m√ºssen im Query deklariert werden
* Werte f√ºr Variablen werden in einem eigenen JSON-Objekt an den Server geschickt

<pre class="fragment"><code class="graphql">query ($storyId: ID!) {
    story(id: $storyId) {
      id
      title body
    }
}
</code></pre>

---

## √úbung: Einen Query ausf√ºhren

_Mach' dich mit der GraphQL-Abfragesprache vertraut_

* √ñffne GraphiQL auf meinem Computer (URL gibt's im Chat)
* Versuche einen Query auszuf√ºhren, der die ersten zehn Stories zur√ºckliefert
  * Id, Titel, Excerpt, Wer hat die Story geschrieben und die ersten zehn Kommentare
* Du kannst Code-Completion und den `Docs`-Explorer (rechts oben) verwenden, um die API zu untersuchen
* Wenn Du fertig bist, bitte Hand in Teams heben üôãüèª‚Äç‚ôÄÔ∏è üôã‚Äç‚ôÇÔ∏è

---

### GraphQL Requests

* <!-- .element: class="demo" --> HTTP Request an die GraphQL API
  * <!-- .element: class="demo" --> request.http im publy-Ordner
  * <!-- .element: class="demo" --> Fehler zeigen
---

## GraphQL Requests

* √úblicherweise nur HTTP POST-Request
  * andere HTTP Verben spielen keine Rolle
  * HTTP Status-Code meist 200 OK, auch im Fehlerfall!
  * Gro√üer Unterscheid zu REST APIs
* Antwort-JSON-Objekt besteht aus maximal drei Feldern:
  * `data`: Die gelesenen Daten (Struktur darunter entspricht der Abfrage)
  * `errors`: Liste mit (technischen) Fehlern, u.a. Fehlermeldung
  * `extensions`: Freibelegbares Objekt f√ºr propriet√§re Erweiterungen (z.B. Debug-Informationen)


---
 
# Das GraphQL Schema

---

### Das GraphQL Schema

* GraphQL APIs m√ºssen in einem Schema beschrieben werden.
* In dem Schema werden Objekte (Typen) mit Feldern beschrieben.
* Das Schema selbst ist zur Laufzeit mit einem _Introspection Query_ abfragbar
* Je nach Framework gibt's unterschiedliche M√∂glichkeiten, das Schema zu definieren
  * **Schema-first**: erst Schema beschreiben, dann implementieren
  * **Code-first**: Schema wird aus (Java-)Code generiert
  * Java-Frameworks verwenden i.d.R. Schema-first (bis auf MicroProfile GraphQL)  

---

### Beschreibung des Schemas

* Mit der [Schema Definition Language](https://graphql.org/learn/schema/) 
* Per [Java API](https://www.graphql-java.com/documentation/schema) in
  GraphQL-Java 
* In der Regel wird die **SDL** verwendet 
  * Java API nur f√ºr _Type Resolver_ und eigene Skalare

---

### Die SDL

* <!-- .element: class="demo" --> Demo: Schema-Definition 
  * <!-- .element: class="demo" --> ping-Feld
  * <!-- .element: class="demo" --> Argument!
  * <!-- .element: class="demo" --> R√ºckgabewert-String

---

### Die SDL

Beschreibung eines *Objekt Types*

<pre><code class="graphql">
  type Story {
    id: ID!

    title: String!
    body: String!
  }
</code></pre>

* Beschrieben werden **Felder** mit **Return Types**
* Ein Ausrufezeichen zeigt an, dass das Feld nicht _nullable_ ist

---

### Dokumentation und Kommentare

* Dokumentation mit drei doppelten Anf√ºhrungszeichen
  * Markdown zur Formatierung erlaubt
* Kommentare mit Hash-Zeichen
  * Dokumentation ist Bestandteil der API, Kommentare nicht

<pre class="fragment"><code class="graphql">
  """
  A `Story` is the main object in our service.
  """
  type Story {
    """Identifies this object"""
    id: ID!

    # todo: implement new tags-field (PROJ-666)
  }
  
</code></pre>

---

## Skalare Typen

* Skalare Typen entsprechen primitiven Typen in Java
  * Sind die Enden im Objekt-Graphen
* Standard-Typen: ID, String, Boolean, Int, Float
  * ID wird als String gelesen und geschrieben, soll aber nicht interpretiert werden


<pre class="fragment"><code class="graphql">
  type Member {
    id: ID!

    username: String!

    # no exclamation mark: can be null
    likes: Int

    amount: Float!

    activeMember: Boolean
}
</code></pre>
  

* Man kann eigene skalare Typen bauen
---

### Aufz√§hlungstypen (enum)

* Wie in Java

<pre class="fragment"><code class="graphql">
  enum ReactionType {
    like,
    laugh,
    thumbUp
  }
</code></pre>

---

### Referenzen

* Referenzen auf andere Objekt-Typen

<pre class="fragment"><code class="graphql">
  type Member {
    # ...
  }

  type Comment {
    # ...
  }

  type Story {
    """Reference to the Member that has written this Story"""
    writtenBy: Member!

    comments: [Comment!]!

  }
</code></pre>

---

### Argumente

* Felder k√∂nnen Argumente haben
  * Solche Felder werden auch _Methoden_ genannt
* Die Felder mit ihren Namen und Typen m√ºssen in der API definiert werden
  * Namen sind entscheidend (wie "named arguments" in Kotlin), nicht Reihenfolge (wie in Java)
* Argumente k√∂nnen Default-Werte haben
* Achtung! Argumente d√ºrfen keine Objekt-Typen sein!  


<pre class="fragment"><code class="graphql">
type Story {

  # Mandatory argument maxLength, defaults to 20
  #  if not specified by the client
  excerpt(maxLength: Int! = 20): String!

}  
</code></pre>

---

### Root-Typen

* Root-Typen bilden den Einstiegspunkt f√ºr Queries in den Objekt-Graphen
* Root-Typen sind **Query**, **Mutation** und **Subscription**
  * **Query** ist Pflicht, die beiden anderen Typen optional
* Syntax und Verhalten genauso wie bei Objekt-Typen
* Felder an den Root-Typen werden auch **Root-Felder** genannt


<pre class="fragment"><code class="graphql">
  type Query {
    """Returns a List of all stories"""
    stories: [Story!]!

    """Returns a story by its ID or null"""
    story(id: ID!): Story
  }

  type Mutation {
    addComment(storyId: ID!, memberId: ID!, content: String!): Comment!
  }
</code></pre>

---

### Input-Typen

* Objekt-Typen k√∂nnen nicht als Argument an ein Feld √ºbergeben
* Als Argumente an Feldern k√∂nnen nur skalare Typen, Enums und Input-Typen √ºbergeben werden.
* Ein Input-Type wird mit `input` definiert, sieht ansonsten aus wie ein Objekt-Type
  * Ein Input-Type darf keine Objekt-Typen referenzieren


<pre class="fragment"><code class="graphql">
  input AddCommentInput {
    storyId: ID!
    memberId: ID!
    content: String!
  }

  type Mutation {
    addComment(input: AddCommentInput!): Comment!
  }
</code></pre>

---

### Union Types

* Union Types bilden eine Menge von anderen Typen
* Ein Feld kann ein Typen aus dieser Menge zur√ºckliefern ("A _oder_ B")


<pre class="fragment"><code class="graphql">
  type AddCommentSuccess { newComment: Comment! }
  type AddCommentFailed { errorMessage: String! }

  union AddCommentResult = AddCommentSuccess | AddCommentFailed

  type Mutation {
    addComment(input: AddCommentInput!): AddCommentResult!
  }

</code></pre>

---

### Interfaces

* Mit einem Interface wird erzwungen, dass Objekte √ºber gleiche Felder verf√ºgen
  * Vergleichbar mit Interfaces in Java


<pre class="fragment"><code class="graphql">
  interface Node {
    id: ID!
  }

  type Story implements Node {
    id: ID!  # Field defined in Node-Interface

    title: String! # additional Story fields
  }

  type Comment implements Node {
    id: ID! 

    content: String!
  }

  type User {
    id: ID!
    email: String
  }

  type Query {
    # Returns either Story or Comment, but not User

    node(id: ID!): Node 
  }
</code></pre>

---

### Schema-Evolution

* In GraphQL gibt es nur _eine Version_ der API (kein `/api/v1`, `/api/v2`)
* Das Schema kann jederzeit erweitert werden
  * Clients fragen explizit Felder ab, d.h. durch neue Felder werden sie nicht beeintr√§chtigt
* Man kann Felder mit `deprecated` markieren, um anzuzeigen, dass sie nicht genutzt werden sollen  

<pre class="fragment"><code class="graphql">
  type Query {
    # Ausgangspunkt 
    getStoryById(id: ID!): Story
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  type Query {
    getStoryById(id: ID!): Story

    # Neues Feld, beeintr√§chtigt bestehenden Client nicht
    stories: [Story!]!
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  type Query {
    getStoryById(id: ID!): Story @deprecated("Use story instead")
    story(id: ID!): Story

    stories: [Story!]!
  }
</code></pre>

---

### Das Schema in Spring GraphQL

* Das Schema wird in Dateien mit der Endung `.graphqls` abgelegt
  * Verzeichnis: `main/resources/graphql`
* Spring Boot sammelt alle Schema-Dateien ein und erzeugt ein Schema daraus
* Typen k√∂nnen erweitert werden


<pre class="fragment"><code class="graphql">
  # story.graphqls
  extend type Query {
    story(id: ID!): Story
  }

  # comment.graphqls
  extend type Query {
    comment(id: ID): Comment
  }
</code></pre>

---

### √úbung: Schema beschreiben

---

### Vorbereitung: Das Repository

* `workspace`: Hier arbeiten wir, bitte in der IDE √∂ffnen
  * `workspace/publy-backend`: Spring Boot-Projekt, in dem wir die GraphQL API implementieren
  * `workspace/publy-userservice`: Spring Boot-Projekt mit dem UserService
  * `workspace/steps`: L√∂sungen f√ºr die einzelnen √úbungen

---

### Vorbereitung: Starten der Anwendung

* Verzeichnis `workspace` in der IDE √∂ffnen
* Dort sind zwei Spring Boot-Anwendungen vorhanden: `publy-userservice` und `publy-backend`

* Schritt 1: Datenbank starten
  * Im `workspace`-Verzeichnis: `docker-compose up -d`
  * (Dauert einen Moment, bis die Daten importiert werden)
* Schritt 2: User Service starten
  * Entweder in der IDE `nh.graphql.publy.userservice.UserserviceApplication` starten
  * oder: im `workspace`-Verzeichnis: `./gradlew :publy-userservice:bootRun`
* Schritt 3: Backend starten
  * Entweder in der IDE `nh.publy.backend.PublyApplication` starten
  * oder: im `workspace`-Verzeichnis: `./gradlew :publy-backend:bootRun`
  * Nach √Ñnderungen (und Speichern, Compilieren) sollte sich das Backend automatisch neu starten

---

### √úbung: Schema beschreiben

* <!-- .element: class="small" --> 
* Lege die Datei `resources/graphql/publy.graphqls` an und beschreibe darin eine API, die folgende Objekt-Typen enth√§lt:
  * **Member** mit `id` und `profileImage`
  * **Story** mit `id`, `title` und `body` und einer Referenz (`writtenBy`) auf den Member
  * Alle Felder in den beiden Typen sind Pflicht (non-nullable), das `id`-Feld ist vom Typ `ID` alle anderen Strings
* Lege den Query-Typen mit folgenden Feldern an:
  * `stories`: Liefert eine Liste der `Story`-Objekte zur√ºck. Nicht nullable.
  * `story`: Liefert eine einzelne Story zur√ºck. Das Feld soll ein Argument haben: `storyId`. Das Feld kann `null` zur√ºckgeben
* F√ºge f√ºr ein oder zwei Felder oder Typen Dokumentation hinzu
* Die Implementierung f√ºr die API machen wir sp√§ter! Du musst also nichts programmieren.
* Sieh dir das API-Schema in GraphiQL an (http://localhost:8090).
  * Pr√ºfe, ob Code Completion funktioniert und ob die Dokumentation im "Docs"-Tab findest
  * Wenn Du √Ñnderungen an der `graphqls`-Datei gemacht hast, musst Du die Anwendung neu bauen, und in GraphiQL
    die Seite im Browser neu laden.
  * Du kannst mal probieren, was passiert, wenn Du einen `stories` bzw `story`-Query ausf√ºhrst.    
    * Eine g√ºltige ID f√ºr eine Story ist z.B. `1`
* Wenn Du fertig bist, bitte Hand in Teams heben üôãüèª‚Äç‚ôÄÔ∏è üôã‚Äç‚ôÇÔ∏è

---

# Implementieren der GraphQL API

---

### Die Beispiel-Anwendung

<img src="images/publy-architektur.png" />

---

### GraphQL Frameworks f√ºr Java

<img style="height:350px" src="images/java-graphql-frameworks.png" />

* graphql-java ist die Grundlage aller(?) Java-Frameworks f√ºr GraphQL
  * Parsen und Validieren der Queries
  * Optimierte Ausf√ºhrung der `DataFetcher` zum Ermitteln der Daten (sp√§ter mehr)
  * Kein Abh√§ngigkeit zu anderen Bibliotheken, auch kein HTTP Endpunkt
  * Alle anderen Frameworks abstrahieren davon und bieten "High-Level" API
* graphql-java-tools-Familie: POJO-basierte Entwicklung, m√∂glicherweise durch die anderen Frameworks nun obsolet
* DGS und spring-graphql fast zeitnah ver√∂ffentlicht
  * M√∂glicherweise wird DGS auf spring-graphql aufgebaut

---

### Verarbeitung eines Queries mit graphql-java

1. Query kommt an (nicht Bestandteil von graphql-java)
2. Query wird geparst und validiert 
3. Ung√ºltige Queries werden abgewiesen (`errors`-Feld in der Antwort) 
4. F√ºr jedes Feld wird ein `DataFetcher` aufgerufen, der verantwortlich daf√ºr ist, die Daten f√ºr das jeweilige Feld zu liefern
5. Die Ergebnisse der DataFetcher werden validiert (insb. hinsichtlich der Typen)
6. Das Ergebnis wird als `data`-Feld bereitsgestellt
7. Das Ergebnis wird an den Client zur√ºckgeschickt (nicht Bestandteil von graphl-java)

* <!-- .element: class="note" --> Unsere Aufgabe ist es, die DataFetcher zu implementieren

---

### DataFetcher (graphql-java)

* Zentrales Interface in GraphQL-Java: Ermitteln die Daten f√ºr _ein_ Feld eines Queries
  * Zum Beispiel f√ºr das Feld `Query.story` oder `Story.title`
  * Hier nur zur Kenntnis, in Spring GraphQL abstrahiert
  * In anderen GraphQL Frameworks auch `Resolver` genannt

* ```java  
  interface DataFetcher<T> {
    T get(DataFetchingEnvironment environment); 
  }  
  ```  

* Beispiel:
* ```java  
  public class PublyDataFetchers {

    public DataFetcher<String> pingFetcher = new DataFetcher() {

      @Override
      public String get(DataFetchingEnvironment env)  {

        String msg = env.getArgumentOrDefault("msg", "Pong!");
        return msg;

      }
    };
  }
  ```


* Jeder DataFetcher wird im **RuntimeWiring** einem Feld der API zugewiesen

---

## GraphQL Java Architektur


<img src="images/graphql-java-architektur.png" />
---

## Spring GraphQL


* [Spring GraphQL](https://spring.io/projects/spring-graphql) bietet eine Abstraktion von GraphQL-Java an
* Erstes Release von Spring GraphQL enthalten in Spring Boot 2.7 (Mai 2022)
  * Projekte k√∂nnen mit dem [Spring initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.7.0-M3&packaging=jar&jvmVersion=11&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=graphql) erzeugt werden (Spring Boot Version 2.7M3 ausw√§hlen)

* Features:
  * Automatische Konfiguration des RuntimeWirings
  * HTTP-Endpunkt f√ºr Requests und Subscriptions automatisch
  * GraphiQL integration per Property
  * Gewohntes Spring-Programmiermodell mit Annotationen etc.
  * Integration in Spring Stack (z.B. Bean Validation, Security)
  * [`spring-boot-starter-graphql`](https://docs.spring.io/spring-boot/docs/2.7.0-SNAPSHOT/reference/htmlsingle/#web.graphql) f√ºr Spring Boot
  * Actuator-Endpunkte f√ºr Spring Boot

---

## Spring GraphQL

* <!-- .element: class="demo" --> Demo: Handler-Funktionen mit `ping`-Feld
* <!-- .element: class="demo" --> Query-Mapping!
* <!-- .element: class="demo" --> Argumente!

---

## Handler-Funktionen


* Anstatt `DataFetcher` werden *Handler-Funktionen* an `Controller`-Klassen implementiert
  * Vorsichtig vergleichbar mit `@RequestMapping` 

  ```java fragment  
    @Controller
    public GraphQLController {

      @QueryMapping
      public String ping() { return "Pong!" }

    }
  ```
  
  * Handler-Funktionen f√ºr Felder am Query-Typen werden mit `@QueryMapping` annotiert
    * Mutations: `@MutationMapping`, Subscription: `@SubscriptionMapping`
  * Der Name der Methode entspricht dem Namen des Feldes des entsprechenden Root-Typen (oder explizit mit `value` setzen)

---

### Parameter von Handler-Funktionen

* `@Argument` um ein einzelnes Argument zu erhalten
* ```graphql
  type Query {
    ping(msg: String): String!
  }
  ```
* ```java
  @QueryMapping
  public String ping(@Argument String msg) { 
    return "Hello " + msg; 
  }
  ```  
* `@Arguments`, um Parameter in einer Java-Klasse zusammenzufassen
* ```graphql
  type Query {
    greet(name: String, msg: String): String!
  }
  ```

* ```java
    class GreetingParams { private String name; private String msg; /* getter+setter... */ }

    @QueryMapping
    public String greet(@Arguments GreetingParams params) { 
      return "Hello " + params.getName(); 
    }
  ```
* `@ProjectedPayload` um einzelne Parameter in einem Interface zusammenzufassen
* ```graphql
    type Query {
      greet(name: String, msg: String): String!
    }
  ```

* ```java
    @ProjectedPayload
    interface GreetingParams { String getName(); String getMsg(); }

    @QueryMapping
    public String greet(@Argument GreetingParams params) { 
      return "Hello " + params.getName(); 
    }
  ```

---
### Parameter von Handler-Funktionen  
  
* F√ºr Input-Typen kann ein Pojo angegeben werden:
* ```graphql
  input GreetingInput { name: String, msg: String }
  type Query {
    greet(input: GreetingInput!): String!
  }
  ```
* ```java
  class GreetingInput { private String name; private String msg; /* getter+setter... */ }

  @QueryMapping
  public String greet(@Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  
* Argumente k√∂nnen mit Bean Validation validiert werden
* ```java
  class GreetingInput { @Size(min=5) private String name; private String msg; /* getter+setter... */ }

  @QueryMapping
  public String greet(@Valid @Argument GreetingInput input) { 
    return "Hello " + input.getName(); 
  }
  ```  

---

### Parameter von Handler-Funktionen

* `DataFetchingEnvironment` und `DataFetchingFieldSelectionSet`: Informationen √ºber den Query und Zugriff auf das Schema
* `@AuthenticationPrincipal`: Aktueller Princial von Spring Security 
* `@ContextValue` Zugriff auf den GraphQL Context
  * Beim Ausf√ºhren jedes Queries wird ein Context-Objekt erzeugt, das Du auch √ºber das `DataFetchingEnvironment`
    abfragen und bef√ºllen kannst.
  * Dabei handelt es sich um ein Objekt mit Key-Value-Paaren
  * H√§ufig wird es zum Beispiel f√ºr Security-Informationen oder zum reinreichen von Services in die DataFetcher verwendet
  * Ich denke, in der Spring-Welt mit Dependency-Injection spielt es eher keine Rolle, deswegen werden wir uns das nicht ansehen

---

### Environment-Objekte

* In GraphQL-Java und Spring-GraphQL werden h√§ufig `Environment`-Objekte verwendet
  * Zum Beispiel: `DataFetchingEnvironment`, `DataLoaderEnvironment`, `TypeResolutionEnvironment`
* Dabei handelt es sich um Objekte, die Informationen √ºber den aktuellen Query, bzw. die aktuelle
  Ausf√ºhrungsumgebung enthalten
  * Anstatt meherere Methoden-Parameter zu verwenden  
  * In anderen Frameworks w√§ren das zum Beispiel `Context` oder `Info`-Klassen
* Das `DataFetchingEnvironment` kannst Du als Parameter an Handler-Funktionen hinzuf√ºgen
  * Hier√ºber bekommst Du z.B. Informationen √ºber den aktuellen Query und Zugriff auf das Schema



---

## √úbung: Handler-Funktionen

_Implementiere zwei Handler-Funktionen_

* Eine Handler-Funktion `Query.stories` und f√ºr `Query.story(id: ID!)`
* Lege dazu eine neue Controller-Klasse an (`PublyGraphQLController`)
* Du kannst in der Controller-Klasse das `StoryRepository` verwenden.
  * Darin sind Methoden zum Ermitteln der Stories aus der Datenbank enthalten.
* Folgende Queries sollten danach funktionieren:

<pre class="fragment"><code class="graphql">
  query {
    stories {
      id title body
     
      writtenBy {
        id profileImage
      }
    }
  }
</code></pre>

<pre class="fragment"><code class="graphql">
  query {
    story(storyId: 1) {
      id title body
     
      writtenBy {
        id profileImage
      }
    }
  }
</code></pre>

* Wenn Du fertig bist, bitte Hand in Teams heben üôãüèª‚Äç‚ôÄÔ∏è üôã‚Äç‚ôÇÔ∏è

---

## Exkurs: Listen mit GraphQL

* Typische Anforderungen: Sortieren, Filtern, Paginieren
* Wie k√∂nnten wir das Umsetzen? ü§î

---

## Handler-Funktionen an Objekt-Typen

* <!-- .element: class="demo" --> Demo: Excerpt-Feld hinzuf√ºgen
  * <!-- .element: class="demo" --> `SchemaMapping` Implementieren !

---

### Handler-Funktionen an Objekt-Typen

* Felder, die an einem Java-Objekt definiert sind, die von einer Handler-Funktion
  zur√ºckgeliefert werden, werden automatisch per Reflektion von Spring-GraphQL abgefragt
  * Voraussetzung: Name des Java-Felder/getter-Methode entspricht Namen am GraphQL Schema
  * Beispiel: `body`- und `writtenBy`-Feld an der `Story`-Entity
* Wenn es kein Feld am Java-Objekt gibt, oder es sich anders verh√§lt, als von der GraphQL
  API erwartet, m√ºssen wir auch daf√ºr Handler-Funktionen schreiben
* (Felder, die an Java Objekten existieren, aber nicht in der GraphQL API k√∂nnen nie vom 
  Client abgefragt werden.)

---

### SchemaMapping

* Die Funktion wird dann mit `@SchemaMapping` annotiert
  * Name muss dem Namen des Feldes in der API entsprechen
  * Parameter bestimmt das `Source`-Objekt, auf dem das Feld ermittelt werden soll
  * Das Source-Objekt stammt aus einem vorherigen DataFetcher

* ```java
  @Controller
  class GraphQLController {

    @SchemaMapping  
    public String excerpt(Story source, @Argument int maxLength) {
      return source.getBody().substring(0, maxLength);
    }
  }
  ```

* Wenn die als Parameter √ºbergebene Klasse nicht so hei√üt, wie im GraphQL Schema,
  kann mit `typename` der Typ explizit gesetzt werden

* ```java
  @SchemaMapping(typeName="Story")
  public String excerpt(StoryDto source) {
    // ...
  }
  ```

* `@QueryMapping` und `@MutationMapping` sind nur Aliase f√ºr 
  * `@SchemaMapping(typeName="Query")` bzw.
  * `@SchemaMapping(typeName="Mutation")`

  
---

## Asynchrone Handler-Funktionen

* <!-- .element: class="demo" --> Instrumentation hinzuf√ºgen
  * <!-- .element: class="demo" --> excerpt-Feld slowdown aktivieren
  * <!-- .element: class="demo" --> stories abfragen und Report auswerten
  * <!-- .element: class="demo" --> CompletableFuture


---

### Asynchrone Handler-Funktionen

* Handler-Funktionen werden grunds√§tzlich nacheinander ausgef√ºhrt 
* Handler-Funktionen k√∂nnen aber `CompletableFuture`, `Flux` oder `Mono`-Objekte zur√ºckliefern
* Dann werden mehrere Handler-Funktionen parallel ausgef√ºhrt

```java fragment  
  @Service
  public class DomainService {
    @Async
    CompletableFuture<String> determineExcerpt(Story story, int maxLenght) {
      // long running task...
    }
  }

  @Controller
  public class GraphQLController {
    @Autowired DomainService domainService;

    @SchemaMapping
    public CompletableFuture<String> excerpt(Story story, @Argument int maxLength) {
      return domainService.determineExcerpt(story, maxLength); // asynchron bzw. reaktiv
    }
  }
```

---

### √úbung: Zugriff auf externen Service

* Wir erweitern den Member-Typen um das User-Objekt:

* ```graphql
  type User {
    id: ID!
    name: String!
    email: String!
  }

  type Member {
    # ...
    user: User
  }
  ```
* Die `Member`-Klasse hat aber keine Referenz auf den User (nur dessen Id)
* ```java
  @Entity
  public class Member {
    // ...
    @NotNull
    private String userId;

    public String getUserId() { return this.userId };
  }
  ```
* Der User kommt aus dem `UserService` (externer Micro-Service)


---

### √úbung: Schema-Mapping 

* Erg√§nze das Schema
  * Neuer Type `User`, Felder: `id` (ID), `name` (String) und `email` (String). Alle non-nullable. 
  * Erweiter den `Member`-Typen um das Feld `user` (Type: `User`, nullable).
* F√ºhre den untenstehenden Query aus. Was kommt f√ºr `user` zur√ºck und warum?  
* Implementiere die Schema-Mapping-Funktion f√ºr das Feld
  * Die Schema-Mapping-Funktion soll asynchron funktionieren
  * Der `UserService` ist bereits implementiert
* Der folgende Query sollte dann einen User zur√ºckliefern:

<pre class="fragment"><code class="graphql">
  query {
    story(storyId: 1) {
      id 
      writtenBy {
        id

        # Hier sollten nun Daten kommen:
        user {
          id name email
        }

      }
    }
  }
</code></pre>

* Wenn Du fertig bist, bitte Hand in Teams heben üôãüèª‚Äç‚ôÄÔ∏è üôã‚Äç‚ôÇÔ∏è

---

## Optimierungen

---

### DataLoader

* Was passiert, wenn wir folgenden Query ausf√ºhren:

<pre class="fragment"><code class="graphql">
  query {
    stories {
      writtenBy { user { id email } }
    }
  }
</code></pre>


* Wir haben sehr viele einzelne Calls zum Micro-Service üò®
* Wir haben doppelte Aufrufe zum Micro-Service üò± üò±

---

### Problem

<img src="images/dataloader-01.png" />

---

### DataLoder

* Ein `DataLoader` "verz√∂gert" das Laden von Daten

* <img src="images/dataloader-02.png" />

---

### DataLoader

* Ein `DataLoader` "verz√∂gert" das Laden von Daten
* In einem DataFetcher/Handler-Funktion √ºbergibst Du an einen DataLoader eine ID o.√§.
* Der DataLoader sammelt die IDs ein
* Wenn alle IDs eingesammelt wurden, wird die Implementierung des DataLoaders aufgerufen
* In der Implementierung bekommst Du alle IDs √ºbergeben und kannst einen optimierten Call machen
  * Zum Beispiel Zusammenfassung in SQL-Statements (`where ID in ...`)
  * Du bekommmst jede ID auch nur einmal √ºbergeben

---

### Verwenden vom DataLoader

* Den DataLoader kannst Du dir in deine Handler-Funktionen √ºbergebenlassen
* Es handelt sich dabei um ein Interface mit zwei Typ-Parametern:
  * `Key`: Typ des Keys, den Du beim Verwenden an den DataLoader √ºbergeben willst
  * `Value`: Typ des Java-Objekts, das der DataLoader f√ºr einen Key zur√ºckliefert


```java fragment
public CompletableFuture<User> user(Member member, DataLoader<String, User> userLoader) {
  String userId = member.getUserId();  // UserId ist in DB gespeichert

  return userLoader.load(userId); // Laden des Users wird verz√∂gert
}
```

---


### Implementierung und Registrieren vom DataLoader

* Es gibt mehrere Wege
* In der `BatchLoaderRegistry` gibt es Hilfsfunktionen
* Die `BatchLoaderRegistry` steht als Spring Bean zur Verf√ºgung
* Mit `forTypePair` registrierst Du einen BatchLoader f√ºr ein Key-Value-Paar
* Die Methode erwartet eine Callback-Funktion:
*  zwei Parameter: die Liste mit den Keys und das `BatchLoaderEnvironment`
*  R√ºckgabe: die Liste mit den geladenen Objekten als Flux
* ```java
  public PublyGraphQLController(/* ... */, BatchLoaderRegistry registry) {

    registry.forTypePair(String.class, User.class).registerBatchLoader(

      (List<String> keys, BatchLoaderEnvironment env) -> {
        // findUsers liefert Flux<User> zur√ºck. 
        return userService.findUsers(keys);
      }
    );

  }
  ```
* Jeder Key wird nur einmal in die Liste eingef√ºgt, du bekommst also keine doppelten Keys
  * Selbst wenn Du also nicht _alle_ Objekte  mit _einem_ Request laden/ermitteln kannst,
    verhinderst Du immerhin doppeltes Laden
* Wichtig! Die Funktion muss die Objekte in derselben Reihenfolge zur√ºckliefern,
  in der die Keys √ºbergeben wurden.
  * Konnte f√ºr einen Key kein Objekt ermittelt werden, muss an der Stelle `null`
  zur√ºckgegeben werden

---

### MappedBatchLoader

* Der BatchLoader liefert eine _Liste_ von Objekten zur√ºck
* Die enthaltenen Objekte m√ºssen in derselben Menge und Reihenfolge wie die Keys zur√ºckgeliefert werden.
* Alternativ kann ein `MappedBatchLoader` verwendet werden, der ein Mono-Objekt mit einer Map zur√ºckliefert
* Die Map enth√§lt dann Key-Value-Paare mit einem gelesenen Objekt jeweils f√ºr einen Key. Objekte, die nicht gefunden
  wurden werden auch nicht in die Map aufgenommen.

```java fragment  
public PublyGraphQLController(/*... */, BatchLoaderRegistry registry) {

  registry.forTypePair(String.class, User.class).registerMappedBatchLoader(

    (List<String> keys, BatchLoaderEnvironment env) -> {
      // zur√ºckgeben: Mono<Map<String, User>>
    }

  );
}
```


---

### BatchMapping

* In einfachen F√§llen kann der MappedBatchLoader mit einer BatchMapping-Funktion implementiert werden
* Das ist eine Handler-Funktion, der automatisch eine Liste von Objekten √ºbergeben wird (zum Beispiel Liste von Member-Objekten)
* Die Handler-Funktion liefert dann entweder ein Mono mit einer Map oder ein Flux mit Objekten zur√ºck (wie vorher gesehen).
* Achtung! Darauf achten, dass `equals` und `hashCode`-Methoden in den Objekten, die als Keys verwendet werden, korrekt implementiert sind!

```java fragment  
@Controller
public class PublyGraphQLController {

  @BatchMapping
  public Flux<User> user(List<Member> member) {
    List<String> keys = member.stream().map(Member::getUserId).collect(Collectors.toList());

    return userService.findUsers(keys);
  }

  // -- oder: --

  @BatchMapping
  public Mono<Map<Member, User>> user(List<Member> member) {
    // ...
  }


  // BatchLoaderRegistry und SchemaMapping f√ºr User-Feld entfallen jetzt
}
```

---

### DataFetchingFieldSelectionSet

* Das `DataFetchingFieldSelectionSet` enth√§lt eine Liste aller Felder, die im aktuellen Query abgefragt sind
* Hiermit kannst Du weitere Optimierungen der Query-Verarbeitung vornehmen, zum Beispiel optimale
  SQL-Queries generieren
* Das `DataFetchingFieldSelectionSet` kannst Du an deine Handler-Funktionen √ºbergeben lassen.

```java fragment  
@QueryMapping List<Story> stories(DataFetchingFieldSelectionSet selectionSet) {

  if (s.contains("comments") ) {
    // SQL Statement mit JOIN auf Comment-Tabelle
    return ...;
  }

  // SQL Statement nur mit Stories
  return ...;
  
}  
```
  
---


### Security

* Wie √ºblich Spring Security verwenden
* √úberlegung: wo wird GraphQL API abgesichert?
  * /graphql-Endpunkt absichern
  * und/oder einzelne Handler-Funktionen mit `@PreAuthorize` absichern
  * und/oder Domain-Layer absichern mit `@PreAuthorize` absichern

---

### Beispiel: Security

* <!-- .element: class="demo" --> AddCommentMutation
  * <!-- .element: class="demo" --> Aus Material kopieren, Handler-Funktion implementieren
  * <!-- .element: class="demo" --> AuthenticationPrincipal f√ºr Member
  * <!-- .element: class="demo" --> PreAuthorize

---

### Handler-Funktionen mit Security  

* Handler-Funktionen k√∂nnen mit `@AuthenticationPrincipal` sich den aktuellen Principal √ºbergeben lassen

```java fragment  
public Story addStory(@Argument AddStoryInput input, @AuthenticationPrincipal PublyUser user) {
  Long storyWrittenById = user.getId();

  return domainService.addStory(storyWrittenById, input.getTitle(), input.getBody());
})  
```

---

### Fehlerbehandlung

* <!-- .element: class="demo" --> Beispiel: Bean Validation
  * <!-- .element: class="demo" --> @Size und @Valid hinzuf√ºgen

---

### Fehlerbehandlung

* Fehler, die nicht in einer Handler-Funktion verarbeitet werden, werden im `errors`-Feld zur√ºckgeliefert:
* ```json 
  {
    "errors": [
      {
        "message": "addComment.input.content: Gr√∂√üe muss zwischen 5 und 2147483647 sein",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "INTERNAL_ERROR"
        }
      }
    ]
  }
  ```
* ```json 
  {
    "errors": [
      {
        "message": "Unauthorized",
        "locations": [
          {
            "line": 2,
            "column": 3
          }
        ],
        "path": [
          "addComment"
        ],
        "extensions": {
          "classification": "UNAUTHORIZED"
        }
      }
    ]
  }
  ```

---

### Fehlerbehandlung

* Das `errors`-Objekt ist nur eingeschr√§nkt spezifiziert:
  * `message`: Fehlermeldung
  * `locations`: Auf welche Code-Stelle im Query bezieht sich der Fehler (wenn vorhanden)
  * `path`: Pfad zum Feld, das den Fehler verursacht hat (wenn vorhanden)
  * `extensions`: Propriet√§re Erweiterungen (`classification` kommt von Spring GraphQL)
  * Keines dieser Felder ist im Schema beschrieben!
* `errors`-Objekt nur f√ºr "Request Errors" verwenden, wenn der Query gar nicht
  oder nicht vern√ºnftig ausgef√ºhrt werden kann
* Sonst lieber "fachliche" Fehler-Objekte zur√ºckliefern
  * Das ist insbesondere bei Mutations sinnvoll, da hier Fehler nicht unwahrscheinlich sind
  * Auch f√ºr andere Felder √ºberlegen, um API abw√§rtskompatibel zu halten

---

### Explizite R√ºckgabetypen

* Beispiel 1: **Query-Ergebnisse**
* ```graphql
  type Query { 
    stories: [Story!]! 
  }
  ```
* Was machen wir, wenn wir dem Ergebnis weitere Informationen hinzuf√ºgen wollen, z.B. wie viele Stories gibt es eigentlich?
* √Ñnderung am R√ºckgabetyp w√§re hier nicht abw√§rtskompatibel! üò¢
* ```graphql
  type StoriesPayload {
    stories: [Story!]!

    maxStories: Int!
  }

  type Query { 
    stories: [Story!]! 
  }
  ```
---

### Explizite R√ºckgabetypen

* Beispiel 2: **Behandlung von Fehlern**  
* ```graphql
  type Mutation { 
    addComment: [Comment!]! 
  }
  ```
* Hier k√∂nnen wir keine Informationen hinterlegen, warum das Anlegen eines Kommentars m√∂glicherweise nicht geklappt hat
* ```graphql
  type AddCommentPayload {
    newComment: Comment
    errorMessage: String
  }

  type Mutation { 
    addComment: AddCommentPayload!
  }
  ```
* Dieses Objekt k√∂nnen wir jederzeit erweitern. 
* Fehler- und nicht-Fehlerfall sind in diesem Fall zwei unterschiedliche R√ºckgaben. Das k√∂nnen wir mit einem union-Typen ausdr√ºcken:
* ```graphql
  type AddCommentSuccessPayload { newComment: Comment! }
  type AddCommentFailedPayload { errorMessage: String! }
  union AddCommentPayload = AddCommentSuccessPayload | AddCommentFailedPayload

  type Mutation { 
    addComment: AddCommentPayload!
  }
  ```
* Der Server liefert je nach Situationen einen der beiden Typen zur√ºck.
  * Achtung! Umstellung von type- auf union-Type im R√ºckgabewert ist nicht abw√§rtskompatibel!

---

# GraphQL APIs testen

---

### Test

* Zum Testen deiner Anwendung gibt es einen `@GraphQLTest`.
* Dieser erzeugt u.a. Controller-Klassen und RuntimeWirings (also GraphQL Infrastruktur)
* In diesem Test kann ein `GraphQlTester` verwendet werden, um GraphQL Queries auszuf√ºhren
* Das Ergebnis des Queries kann dann validiert werden
  * Mit JSON-Path ausdr√ºcken kann auf Teile des Ergebnisses zugegriffen werden
  * Die Teile k√∂nnen in unterschiedliche Formate konvertiert werden

```java fragment

@GraphQlTest
public class PublyGraphQLControllerTest {

  // ausgelassen: Mocks konfigurieren, z.B. f√ºr Repositories mit @MockBean

  @Autowired
  GraphQlTester graphQlTester;

  private final String query = "query { ping }";

  @Test
  void pingReturnsPong() {
    // Query ausf√ºhren
    GraphQlTester.Response response = graphQlTester.document(query)
      .execute();

    // Ergebnis validieren
    response
      .path("ping").entity(String.class).isEqualTo("pong");

  }
```

---

### GraphQlTester

* Der Query kann entweder direkt als String √ºbergeben werden (wie gesehen)
* oder in einer Datei abgelegt werden (`xyz.graphql`), die im Klassenpfad sein muss

```fragment java
@Test
void pingReturnsPong() {

  graphQlTester.document("query { ping } "); // ...

  graphQlTester.documentName("ping-test-query"); // erwartet ping-test-query.graphql im Klassenpfad
}

``` 

---

### Der WebGraphQlTester

* Mit dem `WebGraphQlTester` k√∂nnen GraphQL Requests √ºber HTTP gemacht werden
* An einen laufenden Server oder in-place
* Dazu kann ein gewohnten `@SpringBootTest` geschrieben werden
* Die Testklasse muss au√üerdem mit `@AutoConfigureHttpGraphQlTester` annotiert werden
* API ansonsten wie GraphQlTester

```java fragment
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureHttpGraphQlTester
public class PublyGraphQLControllerWebTest {
  @Autowired
  private WebGraphQlTester webGraphQlTester;

  @Test
  void pingReturnsPong() {
    // Query ausf√ºhren
    webGraphQlTester.document("query { ping }")
      .execute()
      .validate(/* ... */);
  }
}
```

---

### WebGraphQlTester

* Der injizierte `WebGraphQlTester` ist fertig konfiguriert
* Kann aber pro Request angepasst werden, z.B. um HTTP Header zu setzen
* dazu muss eine neue Instanz mit `mutate` erzeugt werden

```java fragment
  graphQlTester
      .mutate() // erzeugt neue Instant, die konfiguriert werden kann
      .header("Authorization", "Bearer user-mock-token")
      .build()
      .document(query) /* konfigurierte Instanz verwenden... */
```

---

### √úbung: Tests

_Schreibe einen Test f√ºr unsere GraphQL-API_

* Der Test kann z.B. eine einzelne Story mit einer ID abfragen, und sicherstellen, dass die abgefragten Felder korrekt in der Antwort enthalten sind:
  * ```graphql

    query { 
      story(storyId: 1) {
        title
        body

        member { id }
      }
    }
    ```
* Verwende den `@GraphlTest`
  * Der Controller wird dabei erzeugt, aber die Repositories m√ºssen gemockt werden
* Im Workspace findest Du im `test`-Verzeichnis eine Klasse `AbstractPublyGraphQLTest`, die Du als Basis verwenden kannst
  * Darin sind schon die Mock-Beans konfiguriert
  * Es gibt Hilfsfunktionen zum Konfigurieren der Mocks mit Mockito
  * Du kannst diese Funktionen in deinen Testf√§llen aufrufen oder selbst mit Mockito mocken
* Wenn Du fertig bist, bitte Hand in Teams heben üôãüèª‚Äç‚ôÄÔ∏è üôã‚Äç‚ôÇÔ∏è



             </textarea
          >
        </section>
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit GraphQL!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>
            <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a>
          </p>
          <p>
            <a href="https://nilshartmann.net" target="_blank"
              >https://nilshartmann.net</a
            >
          </p>
          <p>
            <a
              href="https://www.xing.com/profile/Nils_Hartmann2/cv"
              target="_blank"
              >Xing</a
            >
          </p>

          <p>
            Twitter:
            <a href="https://twitter.com/nilshartmann" target="_blank"
              >@nilshartmann</a
            >
          </p>
        </section>
      </div>
    </div>
    <script src="revealjs/reveal.js/dist/reveal.js"></script>
    <script src="revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="revealjs/config.js"></script>
  </body>
</html>
